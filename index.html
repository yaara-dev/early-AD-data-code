<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ExSeq Brain AD - Spatial Genomics Data Visualization</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
  <script src="https://cdn.plot.ly/plotly-2.26.0.min.js"></script>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: #f5f5f5;
      color: #333;
      padding: 6px;
      overflow-x: hidden;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      background: white;
      border-radius: 6px;
      padding: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    h1 {
      margin-bottom: 6px;
      color: #2c3e50;
      font-size: 16px;
      font-weight: 600;
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 6px;
      margin-bottom: 6px;
      padding: 6px;
      background: #f9f9f9;
      border-radius: 4px;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 3px;
    }

    .control-group label {
      font-size: 10px;
      font-weight: 600;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .control-group select,
    .control-group input[type="text"],
    .control-group input[type="range"] {
      padding: 4px 8px;
      border: 1px solid #ddd;
      border-radius: 3px;
      font-size: 12px;
    }

    .control-group input[type="file"] {
      font-size: 11px;
      cursor: pointer;
      padding: 4px 0;
    }

    .control-group input[type="range"] {
      width: 100%;
    }

    .control-group select {
      min-width: 0;
    }

    .control-group span {
      font-size: 10px;
      color: #666;
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 5px;
      margin-bottom: 6px;
    }

    .stat-card {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 6px 8px;
      border-radius: 4px;
      min-width: 0;
    }

    .stat-card h3 {
      font-size: 8px;
      opacity: 0.9;
      margin-bottom: 1px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .stat-card p {
      font-size: 14px;
      font-weight: bold;
      line-height: 1.2;
    }

    .stat-card.secondary {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    }

    .stat-card.success {
      background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
    }

    .stat-card.warning {
      background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
    }

    #scatterplot {
      width: 100%;
      border: 1px solid #ddd;
      border-radius: 6px;
      background: white;
    }

    .loading {
      text-align: center;
      padding: 40px;
      color: #666;
    }

    .status {
      text-align: left;
      padding: 6px 10px;
      background: #e8f5e9;
      color: #2e7d32;
      border-radius: 3px;
      margin-bottom: 6px;
      font-size: 10px;
      line-height: 1.3;
    }

    .status.error {
      background: #ffebee;
      color: #c62828;
    }

    .status.loading {
      background: #e3f2fd;
      color: #1976d2;
    }

    .status code {
      background: rgba(0, 0, 0, 0.1);
      padding: 2px 6px;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
    }

    .status.error code {
      background: rgba(255, 255, 255, 0.3);
    }

    /* Tooltip styling */
    .tooltip {
      position: absolute;
      background: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 10px;
      border-radius: 4px;
      pointer-events: none;
      font-size: 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      z-index: 1000;
    }

    .axis-label {
      font-size: 10px;
      fill: #666;
    }

    .x-axis text,
    .y-axis text {
      font-size: 10px !important;
      fill: #666;
    }

    .x-axis line,
    .y-axis line,
    .x-axis path,
    .y-axis path {
      stroke: #999;
      stroke-width: 1;
    }

    #legend {
      font-size: 11px;
      position: relative;
      z-index: 10;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 4px;
      padding: 3px;
      cursor: pointer;
      border-radius: 4px;
      transition: background-color 0.2s;
    }

    .legend-item:hover {
      background-color: rgba(0, 0, 0, 0.05);
    }

    .legend-color {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid rgba(0, 0, 0, 0.2);
      flex-shrink: 0;
    }

    .legend-item.hidden .legend-color {
      opacity: 0.3;
    }

    .legend-item.hidden .legend-label {
      text-decoration: line-through;
      opacity: 0.5;
    }

    /* Gene Selector Styles */
    .gene-selector-container {
      position: relative;
      width: 100%;
    }

    .gene-selector-button {
      width: 100%;
      padding: 6px 8px;
      background: white;
      border: 1px solid #ddd;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 12px;
      text-align: left;
    }

    .gene-selector-button:hover {
      border-color: #999;
    }

    .gene-selector-arrow {
      font-size: 10px;
      color: #666;
      transition: transform 0.2s;
    }

    .gene-selector-button.open .gene-selector-arrow {
      transform: rotate(180deg);
    }

    .gene-selector-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: white;
      border: 1px solid #ddd;
      border-radius: 4px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      z-index: 1000;
      max-height: 300px;
      display: flex;
      flex-direction: column;
      margin-top: 2px;
    }

    .gene-selector-actions {
      display: flex;
      gap: 4px;
      padding: 6px;
      border-bottom: 1px solid #eee;
    }

    .gene-action-btn {
      flex: 1;
      padding: 4px 8px;
      background: #f5f5f5;
      border: 1px solid #ddd;
      border-radius: 3px;
      cursor: pointer;
      font-size: 11px;
      transition: background 0.2s;
    }

    .gene-action-btn:hover {
      background: #e8e8e8;
    }

    .gene-selector-search {
      padding: 6px;
      border-bottom: 1px solid #eee;
    }

    .gene-selector-search input {
      width: 100%;
      padding: 4px 6px;
      border: 1px solid #ddd;
      border-radius: 3px;
      font-size: 11px;
    }

    .gene-selector-list {
      overflow-y: auto;
      max-height: 200px;
      padding: 4px;
    }

    .gene-checkbox-item {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 6px;
      cursor: pointer;
      border-radius: 3px;
      font-size: 11px;
    }

    .gene-checkbox-item:hover {
      background: #f5f5f5;
    }

    .gene-checkbox-item.hidden {
      opacity: 0.5;
    }

    .gene-checkbox-item.hidden .gene-checkbox-label {
      text-decoration: line-through;
    }

    .gene-checkbox {
      cursor: pointer;
    }

    .gene-checkbox-label {
      flex: 1;
      cursor: pointer;
      user-select: none;
    }

    .legend-label {
      flex: 1;
      user-select: none;
    }

    /* Tab Navigation Styles */
    .tabs {
      display: flex;
      gap: 4px;
      margin-bottom: 8px;
      border-bottom: 2px solid #ddd;
    }

    .tab-button {
      padding: 8px 16px;
      background: #f5f5f5;
      border: none;
      border-top-left-radius: 4px;
      border-top-right-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      font-weight: 600;
      color: #666;
      transition: all 0.2s;
    }

    .tab-button:hover {
      background: #e8e8e8;
    }

    .tab-button.active {
      background: white;
      color: #2c3e50;
      border-bottom: 2px solid white;
      margin-bottom: -2px;
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    /* Dashboard Grid */
    .dashboard-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      gap: 10px;
      min-height: 600px;
    }

    .dashboard-cell {
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 8px;
      background: white;
      position: relative;
      min-height: 200px;
    }

    .dashboard-cell h4 {
      margin: 0 0 8px 0;
      font-size: 11px;
      font-weight: 600;
      color: #333;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .dashboard-chart {
      width: 100%;
      height: calc(100% - 30px);
    }

    /* Table styles */
    .summary-table {
      width: 100%;
      font-size: 10px;
      border-collapse: collapse;
    }

    .summary-table th,
    .summary-table td {
      padding: 4px 6px;
      text-align: left;
      border-bottom: 1px solid #eee;
    }

    .summary-table th {
      background: #f9f9f9;
      font-weight: 600;
      color: #666;
    }

    .summary-table tr:hover {
      background: #f5f5f5;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ExSeq Brain AD - Spatial Genomics Data Visualization</h1>
    
    <div class="status" id="status">Initializing...</div>

    <div class="stats" id="stats" style="display: none;">
      <div class="stat-card">
        <h3>Total Records</h3>
        <p id="totalRecords">-</p>
      </div>
      <div class="stat-card secondary">
        <h3>Unique Genes</h3>
        <p id="uniqueGenes">-</p>
      </div>
      <div class="stat-card success">
        <h3>Unique Regions</h3>
        <p id="uniqueRegions">-</p>
      </div>
      <div class="stat-card warning">
        <h3>Visible Points</h3>
        <p id="visiblePoints">-</p>
      </div>
    </div>

    <div class="controls" id="controls">
      <div class="control-group" id="sampleSelectorGroup">
        <label>Sample</label>
        <select id="sampleSelector" onchange="loadSampleFromPath(this.value)">
          <option value="">Select a sample...</option>
        </select>
      </div>
      <div class="control-group" id="fileInputGroup" style="display: none;">
        <label>Load Data (Fallback)</label>
        <input type="file" id="fileInput" accept=".csv" onchange="handleFileSelect(event)" style="padding: 6px 0; cursor: pointer;">
      </div>
      <div class="control-group">
        <label>Region</label>
        <select id="regionFilter" onchange="updateCellTypeFilter(); updateVisualization();">
          <option value="">All Regions</option>
        </select>
      </div>
      <div class="control-group">
        <label>Genes</label>
        <div class="gene-selector-container">
          <button type="button" class="gene-selector-button" id="geneSelectorButton" onclick="toggleGeneSelector()">
            <span id="geneSelectorText">All Genes</span>
            <span class="gene-selector-arrow">â–¼</span>
          </button>
          <div class="gene-selector-dropdown" id="geneSelectorDropdown" style="display: none;">
            <div class="gene-selector-actions">
              <button type="button" class="gene-action-btn" onclick="hideAllGenes()">Hide All</button>
              <button type="button" class="gene-action-btn" onclick="showAllGenes()">Show All</button>
            </div>
            <div class="gene-selector-search">
              <input type="text" id="geneSearchInput" placeholder="Search genes..." oninput="filterGeneList()">
            </div>
            <div class="gene-selector-list" id="geneSelectorList">
              <!-- Gene checkboxes will be populated here -->
            </div>
          </div>
        </div>
      </div>
      <div class="control-group" id="cellTypeFilterGroup" style="display: none;">
        <label>Cell Type</label>
        <select id="cellTypeFilter" onchange="updateVisualization()">
          <option value="">All Cell Types</option>
        </select>
      </div>
      <div class="control-group">
        <label>Z-Slice Range</label>
        <input type="range" id="zRange" min="0" max="10" step="0.1" value="10" 
               oninput="document.getElementById('zRangeValue').textContent = this.value; updateVisualization();">
        <span>Max: <span id="zRangeValue">10</span></span>
      </div>
      <div class="control-group">
        <label>Opacity</label>
        <input type="range" id="opacityRange" min="0.1" max="1" step="0.1" value="0.5"
               oninput="document.getElementById('opacityValue').textContent = this.value; updateVisualization();">
        <span>Value: <span id="opacityValue">0.5</span></span>
      </div>
      <div class="control-group">
        <label>Point Size</label>
        <input type="range" id="pointSize" min="1" max="10" step="0.5" value="2"
               oninput="document.getElementById('pointSizeValue').textContent = this.value; updateVisualization();">
        <span>Size: <span id="pointSizeValue">2</span></span>
      </div>
    </div>

    <!-- Tab Navigation -->
    <div class="tabs">
      <button class="tab-button active" onclick="switchTab(1)">2D View</button>
      <button class="tab-button" onclick="switchTab(2)">3D View</button>
      <button class="tab-button" onclick="switchTab(3)">Dashboard</button>
    </div>

    <!-- Tab 1: 2D View -->
    <div id="tab1" class="tab-content active">
      <div class="chart-container" style="display: flex; gap: 10px; align-items: flex-start; overflow: hidden; max-width: 100%;">
        <div style="flex: 1; min-width: 0; position: relative;">
          <div id="plotly2d" style="width: 100%; height: 550px; border: 1px solid #ddd; border-radius: 4px;"></div>
        </div>
      </div>
    </div>

        <!-- Tab 2: 3D View -->
    <div id="tab2" class="tab-content">
      <div style="margin-bottom: 8px; padding: 6px; background: #f0f0f0; border-radius: 4px; font-size: 11px; color: #666;">
        <strong>3D Controls:</strong> Click and drag to rotate | Scroll to zoom | Right-click and drag to pan | Double-click to reset view
      </div>
      <div class="chart-container" style="display: flex; gap: 10px; align-items: flex-start; overflow: hidden; max-width: 100%;">
        <div style="flex: 1; min-width: 0; position: relative;">
          <div id="plotly3d" style="width: 100%; height: 550px; border: 1px solid #ddd; border-radius: 4px;"></div>
        </div>
      </div>
    </div>

    <!-- Tab 3: Dashboard -->
    <div id="tab3" class="tab-content">
      <div class="dashboard-grid">
        <!-- Cell 1: 2D View -->
        <div class="dashboard-cell">
          <h4>2D View</h4>
          <div style="position: relative; width: 100%; height: calc(100% - 30px);">
            <canvas id="dashboard2d" class="dashboard-chart" style="border: 1px solid #eee; border-radius: 3px;"></canvas>
            <svg id="dashboard2dAxes" style="position: absolute; top: 0; left: 0; pointer-events: none; z-index: 1;"></svg>
          </div>
        </div>
        
        <!-- Cell 2: 3D View -->
        <div class="dashboard-cell">
          <h4>3D View</h4>
          <div style="position: relative; width: 100%; height: calc(100% - 30px);">
            <canvas id="dashboard3d" class="dashboard-chart" style="border: 1px solid #eee; border-radius: 3px;"></canvas>
            <svg id="dashboard3dAxes" style="position: absolute; top: 0; left: 0; pointer-events: none; z-index: 1;"></svg>
          </div>
        </div>
        
        <!-- Cell 3: Summaries Table -->
        <div class="dashboard-cell">
          <h4>Region Statistics</h4>
          <div id="summaryTable" class="dashboard-chart" style="overflow-y: auto;"></div>
        </div>
        
        <!-- Cell 4: Gene Expression Distribution -->
        <div class="dashboard-cell">
          <h4>Gene Expression Distribution</h4>
          <svg id="geneExpressionChart" class="dashboard-chart"></svg>
        </div>
        
        <!-- Cell 5: Region Comparison Heatmap -->
        <div class="dashboard-cell">
          <h4>Region Comparison Heatmap</h4>
          <svg id="regionHeatmap" class="dashboard-chart"></svg>
        </div>
        
        <!-- Cell 6: Z-Slice Distribution -->
        <div class="dashboard-cell">
          <h4>Z-Slice Distribution</h4>
          <svg id="zSliceChart" class="dashboard-chart"></svg>
        </div>
        
        <!-- Cell 7: Cell Type Distribution -->
        <div class="dashboard-cell">
          <h4>Cell Type Distribution</h4>
          <svg id="cellTypeChart" class="dashboard-chart"></svg>
        </div>
        
        <!-- Cell 8: Spatial Density Heatmap -->
        <div class="dashboard-cell">
          <h4>Spatial Density Heatmap</h4>
          <svg id="spatialDensityChart" class="dashboard-chart"></svg>
        </div>
        
        <!-- Cell 9: Expression Level Distribution -->
        <div class="dashboard-cell">
          <h4>Expression Level Distribution</h4>
          <svg id="expressionViolinChart" class="dashboard-chart"></svg>
        </div>
      </div>
    </div>

    <div class="loading" id="loading" style="display: none;">Loading data...</div>
  </div>

  <div class="tooltip" id="tooltip" style="display: none;"></div>

  <script>
    // Sample configuration - loaded dynamically from manifest.json
    let samples = [];

    let rawData = [];
    let filteredData = [];
    let canvas, ctx, axesSvg, xScale, yScale;
    // Removed: canvas2d, ctx2d, axesSvg2d, xScale2d, yScale2d (replaced with Plotly)
    // Removed: canvas3d, ctx3d, axesSvg3d, xScale3d, yScale3d (replaced with Plotly)
    // Dashboard canvas variables restored
    let hasCellType = false;
    let colorScale = null;
    const margin = { top: 30, right: 30, bottom: 45, left: 45 };
    let currentFileName = null;
    const MAX_POINTS_TO_RENDER = 100000; // Maximum points to render for performance
    let renderTimeout = null;
    let hoveredPoint = null;
    let currentTab = 1;
    // Track hidden genes (replaces DOM-based tracking after legends were removed)
    let hiddenGenes = new Set();
    
    // 3D rotation and pan state (still used by dashboard 3D view)
    let rotationX = Math.PI / 6; // 30 degrees
    let rotationY = Math.PI / 6; // 30 degrees
    let panX = 0;
    let panY = 0;
    let isDragging = false;
    let isPanning = false;
    let lastMouseX = 0;
    let lastMouseY = 0;

    // Tab switching function
    function switchTab(tabNumber) {
      currentTab = tabNumber;
      
      // Update tab buttons
      document.querySelectorAll('.tab-button').forEach((btn, idx) => {
        if (idx + 1 === tabNumber) {
          btn.classList.add('active');
        } else {
          btn.classList.remove('active');
        }
      });
      
      // Update tab content
      document.querySelectorAll('.tab-content').forEach((content, idx) => {
        if (idx + 1 === tabNumber) {
          content.classList.add('active');
        } else {
          content.classList.remove('active');
        }
      });
      
      // Legends removed - no need to update visibility
      
      // Update visualizations when switching tabs
      if (rawData && rawData.length > 0) {
        const xExtent = d3.extent(rawData, d => d.x_coordinate);
        const yExtent = d3.extent(rawData, d => d.y_coordinate);
        
        // Re-initialize canvases if needed (in case they weren't visible during first setup)
        // Also re-initialize to get proper dimensions when tab becomes visible
        if (tabNumber === 1) {
          if (!plotly2dInitialized) {
            setup2DView(xExtent, yExtent);
          }
        }
        if (tabNumber === 2) {
          if (!plotly3dInitialized) {
            setup3DView(xExtent, yExtent);
          }
        }
        if (tabNumber === 3) {
          if (!dashboard2dCanvas || !dashboard2dXScale) {
            setupDashboard(xExtent, yExtent);
          }
        }
        
        // Small delay to ensure tab is visible before rendering
        setTimeout(() => {
          updateVisualization();
          // Force dashboard update when switching to tab 3
          if (tabNumber === 3) {
            setTimeout(() => updateDashboard(), 50);
          }
        }, 50);
      }
    }

    // Column name normalization function
    function normalizeColumns(data) {
      // Reset cell type flag before checking
      hasCellType = false;
      
      const normalized = data.map(row => {
        const norm = {};
        // Normalize column names
        norm.region = row.region_name || row.region || '';
        norm.region_area = row.region_area || 0;
        norm.region_proportion = row.region_proportion || 0;
        norm.gene = row.gene || '';
        norm.x_coordinate = row.global_x !== undefined ? row.global_x : (row.x_coordinate !== undefined ? row.x_coordinate : 0);
        norm.y_coordinate = row.global_y !== undefined ? row.global_y : (row.y_coordinate !== undefined ? row.y_coordinate : 0);
        norm.z_coordinate = row.Z !== undefined ? row.Z : (row.z_coordinate !== undefined ? row.z_coordinate : 0);
        norm.cell_id = row.cell || row.cell_id || '';
        norm.fov = row.fov || '';
        // Check if cell_type exists
        if (row.cell_type !== undefined && row.cell_type !== null && row.cell_type !== '') {
          norm.cell_type = row.cell_type;
          hasCellType = true;
        }
        return norm;
      });
      
      return normalized;
    }

    // Load manifest.json to get list of available CSV files
    async function loadManifest() {
      try {
        const manifestPath = 'data/csvs/manifest.json';
        const response = await fetch(manifestPath);
        
        if (!response.ok) {
          throw new Error(`Failed to load manifest: ${response.status} ${response.statusText}`);
        }
        
        const manifest = await response.json();
        samples = manifest;
        
        console.log(`Loaded manifest with ${samples.length} CSV files`);
        return true;
      } catch (error) {
        console.error('Error loading manifest:', error);
        samples = []; // Empty array on error
        return false;
      }
    }

    // Initialize sample selector
    function initializeSampleSelector() {
      const selector = document.getElementById('sampleSelector');
      // Clear existing options except the first one
      while (selector.children.length > 1) {
        selector.removeChild(selector.lastChild);
      }
      
      if (samples.length === 0) {
        const option = document.createElement('option');
        option.value = '';
        option.textContent = 'No samples available';
        selector.appendChild(option);
        return;
      }
      
      samples.forEach((sample) => {
        const option = document.createElement('option');
        option.value = sample.path;
        option.textContent = sample.name;
        selector.appendChild(option);
      });
    }

    // Load normalized data (5 separate CSV files)
    async function loadNormalizedData(basePath) {
      // Extract base name and directory
      const pathParts = basePath.split('/');
      const fileName = pathParts[pathParts.length - 1];
      const dir = pathParts.slice(0, -1).join('/') + (pathParts.length > 1 ? '/' : '');
      
      // Remove _points.csv suffix to get base name
      const baseName = fileName.replace(/_points\.csv$/, '');
      
      // Add cache-busting timestamp to force browser to reload files
      const cacheBuster = '?t=' + Date.now();
      
      const files = {
        points: dir + baseName + '_points.csv' + cacheBuster,
        regions: dir + baseName + '_regions.csv' + cacheBuster,
        pointsRegions: dir + baseName + '_points_regions.csv' + cacheBuster,
        cells: dir + baseName + '_cells.csv' + cacheBuster,
        pointsCells: dir + baseName + '_points_cells.csv' + cacheBuster
      };
      
      // Initialize state
      rawData = [];
      hasCellType = false;
      document.getElementById('status').textContent = 'Loading normalized data...';
      document.getElementById('status').className = 'status loading';
      document.getElementById('loading').style.display = 'block';
      document.getElementById('stats').style.display = 'none';
      document.getElementById('cellTypeFilterGroup').style.display = 'none';
      
      // Clear dashboard canvas visualizations
      [dashboard2dCanvas, dashboard3dCanvas].forEach(canvas => {
        if (canvas && canvas.getContext) {
          const ctx = canvas.getContext('2d');
          ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
      });
      [dashboard2dAxesSvg, dashboard3dAxesSvg].forEach(svg => {
        if (svg) svg.selectAll('*').remove();
      });
      // Clear Plotly plots if initialized
      if (plotly2dInitialized) {
        Plotly.purge('plotly2d');
        plotly2dInitialized = false;
      }
      if (plotly3dInitialized) {
        Plotly.purge('plotly3d');
        plotly3dInitialized = false;
      }
      
      colorScale = null;
      if (renderTimeout) {
        clearTimeout(renderTimeout);
        renderTimeout = null;
      }
      // Removed: canvasInteractivitySetup2d, canvasInteractivitySetup3d (Plotly handles interactivity)
      
      // Reset filters
      document.getElementById('regionFilter').innerHTML = '<option value="">All Regions</option>';
      const geneSelectorList = document.getElementById('geneSelectorList');
      if (geneSelectorList) geneSelectorList.innerHTML = '';
      document.getElementById('cellTypeFilter').innerHTML = '<option value="">All Cell Types</option>';
      hiddenGenes.clear();
      updateGeneSelectorButton();
      
      try {
        // Load all files in parallel
        const [pointsData, regionsData, pointsRegionsData, cellsData, pointsCellsData] = await Promise.all([
          loadCSVFile(files.points),
          loadCSVFile(files.regions),
          loadCSVFile(files.pointsRegions),
          loadCSVFile(files.cells),
          loadCSVFile(files.pointsCells)
        ]);
        
        // Create lookup maps
        const regionsMap = new Map();
        regionsData.forEach(r => {
          regionsMap.set(parseInt(r.region_id), {
            region_name: r.region_name,
            region_area: r.region_area || '',
            region_proportion: r.region_proportion || ''
          });
        });
        
        const cellsMap = new Map();
        cellsData.forEach(c => {
          cellsMap.set(parseInt(c.cell_id), c.cell);
        });
        
        const pointsRegionsMap = new Map();
        pointsRegionsData.forEach(pr => {
          pointsRegionsMap.set(parseInt(pr.point_id), parseInt(pr.region_id));
        });
        
        const pointsCellsMap = new Map();
        pointsCellsData.forEach(pc => {
          pointsCellsMap.set(parseInt(pc.point_id), {
            cell_id: parseInt(pc.cell_id),
            cell_type: pc.cell_type || ''
          });
        });
        
        // Join data
        rawData = [];
        const regionsSet = new Set();
        const genesSet = new Set();
        const cellTypesSet = new Set();
        
        pointsData.forEach(point => {
          const pointId = parseInt(point.point_id);
          const regionId = pointsRegionsMap.get(pointId);
          const cellInfo = pointsCellsMap.get(pointId);
          const region = regionId ? regionsMap.get(regionId) : null;
          const cellId = cellInfo ? cellsMap.get(cellInfo.cell_id) : '';
          
          const norm = {
            region: region ? region.region_name : '',
            gene: point.gene || '',
            x_coordinate: parseFloat(point.X) || 0,
            y_coordinate: parseFloat(point.Y) || 0,
            z_coordinate: parseFloat(point.Z) || 0,
            cell_id: cellId || '',
            fov: point.fov || '',
            region_area: region ? (region.region_area || 0) : 0,
            region_proportion: region ? (region.region_proportion || 0) : 0
          };
          
          if (cellInfo && cellInfo.cell_type) {
            norm.cell_type = cellInfo.cell_type;
            hasCellType = true;
            cellTypesSet.add(cellInfo.cell_type);
          }
          
          if (norm.region) regionsSet.add(norm.region);
          if (norm.gene) genesSet.add(norm.gene);
          
          rawData.push(norm);
        });
        
        // Setup visualization
        setupVisualizationFast(Array.from(regionsSet), Array.from(genesSet), Array.from(cellTypesSet));
        document.getElementById('loading').style.display = 'none';
        document.getElementById('status').textContent = `Loaded ${rawData.length.toLocaleString()} records from normalized data`;
        document.getElementById('status').className = 'status';
        setTimeout(() => {
          document.getElementById('status').style.display = 'none';
        }, 3000);
        
      } catch (error) {
        console.error('Error loading normalized data:', error);
        document.getElementById('status').textContent = 'Error loading normalized data: ' + (error.message || 'Unknown error');
        document.getElementById('status').className = 'status error';
        document.getElementById('loading').style.display = 'none';
      }
    }
    
    // Helper function to load CSV file and return parsed data
    function loadCSVFile(filePath) {
      return new Promise((resolve, reject) => {
        const data = [];
        Papa.parse(filePath, {
          download: true,
          header: true,
          dynamicTyping: true,
          skipEmptyLines: true,
          step: function(result) {
            if (result.data && Object.keys(result.data).length > 0) {
              data.push(result.data);
            }
          },
          complete: function(results) {
            if (results.errors.length > 0) {
              console.warn('Parsing errors for', filePath, ':', results.errors);
            }
            resolve(data);
          },
          error: function(error) {
            reject(error);
          }
        });
      });
    }

    // Load sample from path (tries to load from relative path)
    function loadSampleFromPath(samplePath) {
      if (!samplePath) {
        return;
      }

      currentFileName = samplePath.split('/').pop();
      
      // Check if this is normalized data (ends with _points.csv)
      if (samplePath.includes('_points.csv')) {
        // Load normalized data
        loadNormalizedData(samplePath);
        return;
      }
      
      // Original single-file loading logic
      rawData = [];
      hasCellType = false;
      document.getElementById('status').textContent = 'Loading sample data...';
      document.getElementById('status').className = 'status loading';
      document.getElementById('loading').style.display = 'block';
      document.getElementById('stats').style.display = 'none';
      document.getElementById('cellTypeFilterGroup').style.display = 'none';

      // Clear dashboard canvas visualizations
      [dashboard2dCanvas, dashboard3dCanvas].forEach(canvas => {
        if (canvas && canvas.getContext) {
          const ctx = canvas.getContext('2d');
          ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
      });
      [dashboard2dAxesSvg, dashboard3dAxesSvg].forEach(svg => {
        if (svg) svg.selectAll('*').remove();
      });
      // Clear Plotly plots if initialized
      if (plotly2dInitialized) {
        Plotly.purge('plotly2d');
        plotly2dInitialized = false;
      }
      if (plotly3dInitialized) {
        Plotly.purge('plotly3d');
        plotly3dInitialized = false;
      }

      // Legends removed - no need to clear
      colorScale = null;
      if (renderTimeout) {
        clearTimeout(renderTimeout);
        renderTimeout = null;
      }
      // Removed: canvasInteractivitySetup2d, canvasInteractivitySetup3d (Plotly handles interactivity)

      // Reset filters
      document.getElementById('regionFilter').innerHTML = '<option value="">All Regions</option>';
      const geneSelectorList = document.getElementById('geneSelectorList');
      if (geneSelectorList) geneSelectorList.innerHTML = '';
      document.getElementById('cellTypeFilter').innerHTML = '<option value="">All Cell Types</option>';
      hiddenGenes.clear();
      updateGeneSelectorButton();

      // Track parsing progress
      let rowCount = 0;
      
      // Pre-extract unique values during parsing for faster filter setup
      const regionsSet = new Set();
      const genesSet = new Set();
      const cellTypesSet = new Set();

      Papa.parse(samplePath, {
        download: true,
        header: true,
        dynamicTyping: true,
        skipEmptyLines: true,
        // Note: worker disabled due to URL issues with CDN version
        step: function(result) {
          if (result.data && Object.keys(result.data).length > 0) {
            // Normalize during parsing to avoid second pass
            const norm = {};
            norm.region = result.data.region_name || result.data.region || '';
            norm.gene = result.data.gene || '';
            norm.x_coordinate = result.data.global_x !== undefined ? result.data.global_x : (result.data.x_coordinate !== undefined ? result.data.x_coordinate : 0);
            norm.y_coordinate = result.data.global_y !== undefined ? result.data.global_y : (result.data.y_coordinate !== undefined ? result.data.y_coordinate : 0);
            norm.z_coordinate = result.data.Z !== undefined ? result.data.Z : (result.data.z_coordinate !== undefined ? result.data.z_coordinate : 0);
            norm.cell_id = result.data.cell || result.data.cell_id || '';
            norm.fov = result.data.fov || '';
            norm.region_area = result.data.region_area || 0;
            norm.region_proportion = result.data.region_proportion || 0;
            
            // Check cell_type
            if (result.data.cell_type !== undefined && result.data.cell_type !== null && result.data.cell_type !== '') {
              norm.cell_type = result.data.cell_type;
              hasCellType = true;
              cellTypesSet.add(result.data.cell_type);
            }
            
            // Extract unique values during parsing
            if (norm.region) regionsSet.add(norm.region);
            if (norm.gene) genesSet.add(norm.gene);
            
            rawData.push(norm);
            rowCount++;
            
            // Update status for large files (less frequently for better performance)
            if (rowCount % 100000 === 0) {
              requestAnimationFrame(() => {
                document.getElementById('status').textContent = `Loading sample data... (${rowCount.toLocaleString()} rows loaded)`;
              });
            }
          }
        },
        complete: function(results) {
          console.log('CSV parsing complete. Rows:', rawData.length, 'Errors:', results.errors);
          
          if (rawData.length === 0) {
            // Check if this is a CORS/network error
            const hasNetworkError = results.errors.some(e => 
              e.message && (e.message.includes('NetworkError') || e.message.includes('CORS') || e.message.includes('fetch') || e.message.includes('Failed to fetch'))
            ) || results.errors.length > 0;
            
            if (hasNetworkError && window.location.protocol === 'file:') {
              // Show file input if opened as file:// and we got a network error
              document.getElementById('fileInputGroup').style.display = 'flex';
              document.getElementById('sampleSelectorGroup').style.display = 'none';
              document.getElementById('status').style.display = 'none';
              document.getElementById('loading').style.display = 'none';
              return;
            }
            
            document.getElementById('status').textContent = 'Error: No data loaded from CSV file. The file may be empty or invalid.';
            document.getElementById('status').className = 'status error';
            document.getElementById('loading').style.display = 'none';
            return;
          }

          // Setup visualization with pre-extracted unique values
          setupVisualizationFast(Array.from(regionsSet), Array.from(genesSet), Array.from(cellTypesSet));
          document.getElementById('loading').style.display = 'none';
          document.getElementById('status').textContent = `Loaded ${rawData.length.toLocaleString()} records from ${currentFileName}`;
          document.getElementById('status').className = 'status';
          // Hide status after a moment
          setTimeout(() => {
            document.getElementById('status').style.display = 'none';
          }, 3000);
        },
        error: function(error) {
          console.error('Error loading CSV:', error);
          // Show file input if opened as file://
          if (window.location.protocol === 'file:') {
            document.getElementById('fileInputGroup').style.display = 'flex';
            document.getElementById('sampleSelectorGroup').style.display = 'none';
            document.getElementById('status').style.display = 'none';
          } else {
            document.getElementById('status').textContent = 'Error loading file: ' + (error.message || 'Unknown error');
            document.getElementById('status').className = 'status error';
          }
          document.getElementById('loading').style.display = 'none';
        }
      });
    }

    // Handle file selection (fallback method)
    function handleFileSelect(event) {
      const file = event.target.files[0];
      if (!file) {
        return;
      }

      if (!file.name.endsWith('.csv')) {
        document.getElementById('status').textContent = 'Error: Please select a CSV file.';
        document.getElementById('status').className = 'status error';
        return;
      }

      currentFileName = file.name;
      
      // Check if this is a normalized _points.csv file
      if (file.name.includes('_points.csv')) {
        // For file input, we can't automatically load other files
        // Show helpful message
        document.getElementById('status').textContent = 'Note: Normalized data requires all 5 files. Please use the sample selector dropdown instead, or select the original combined CSV file.';
        document.getElementById('status').className = 'status';
        // Still try to load just the points file as a fallback
        // But warn that region and cell data will be missing
        document.getElementById('status').textContent = 'Warning: Loading points file only. Region and cell data will be missing. Please use the sample selector for full normalized data.';
        document.getElementById('status').className = 'status error';
      }
      
      rawData = [];
      hasCellType = false;
      
      document.getElementById('status').textContent = 'Loading file...';
      document.getElementById('status').className = 'status loading';
      document.getElementById('loading').style.display = 'block';
      document.getElementById('stats').style.display = 'none';
      document.getElementById('cellTypeFilterGroup').style.display = 'none';

      // Clear dashboard canvas visualizations
      [dashboard2dCanvas, dashboard3dCanvas].forEach(canvas => {
        if (canvas && canvas.getContext) {
          const ctx = canvas.getContext('2d');
          ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
      });
      [dashboard2dAxesSvg, dashboard3dAxesSvg].forEach(svg => {
        if (svg) svg.selectAll('*').remove();
      });
      // Clear Plotly plots if initialized
      if (plotly2dInitialized) {
        Plotly.purge('plotly2d');
        plotly2dInitialized = false;
      }
      if (plotly3dInitialized) {
        Plotly.purge('plotly3d');
        plotly3dInitialized = false;
      }

      // Legends removed - no need to clear
      colorScale = null;
      if (renderTimeout) {
        clearTimeout(renderTimeout);
        renderTimeout = null;
      }
      // Removed: canvasInteractivitySetup2d, canvasInteractivitySetup3d (Plotly handles interactivity)

      // Reset filters
      document.getElementById('regionFilter').innerHTML = '<option value="">All Regions</option>';
      const geneSelectorList = document.getElementById('geneSelectorList');
      if (geneSelectorList) geneSelectorList.innerHTML = '';
      document.getElementById('cellTypeFilter').innerHTML = '<option value="">All Cell Types</option>';
      hiddenGenes.clear();
      updateGeneSelectorButton();

      // Read file using FileReader
      const reader = new FileReader();
      
      reader.onprogress = function(e) {
        if (e.lengthComputable) {
          const percentLoaded = Math.round((e.loaded / e.total) * 100);
          document.getElementById('status').textContent = `Loading file... ${percentLoaded}%`;
        }
      };
      
      reader.onload = function(e) {
        const csvText = e.target.result;
        document.getElementById('status').textContent = 'Parsing CSV data...';
        
        // Track parsing progress
        let rowCount = 0;
        
        // Pre-extract unique values during parsing
        const regionsSet = new Set();
        const genesSet = new Set();
        const cellTypesSet = new Set();
        
        Papa.parse(csvText, {
          header: true,
          dynamicTyping: true,
          skipEmptyLines: true,
          // Note: worker disabled due to URL issues with CDN version
          step: function(result) {
            if (result.data && Object.keys(result.data).length > 0) {
              // Normalize during parsing
              const norm = {};
              norm.region = result.data.region_name || result.data.region || '';
              norm.gene = result.data.gene || '';
              norm.x_coordinate = result.data.global_x !== undefined ? result.data.global_x : (result.data.x_coordinate !== undefined ? result.data.x_coordinate : 0);
              norm.y_coordinate = result.data.global_y !== undefined ? result.data.global_y : (result.data.y_coordinate !== undefined ? result.data.y_coordinate : 0);
              norm.z_coordinate = result.data.Z !== undefined ? result.data.Z : (result.data.z_coordinate !== undefined ? result.data.z_coordinate : 0);
              norm.cell_id = result.data.cell || result.data.cell_id || '';
              norm.fov = result.data.fov || '';
              norm.region_area = result.data.region_area || 0;
              norm.region_proportion = result.data.region_proportion || 0;
              
              if (result.data.cell_type !== undefined && result.data.cell_type !== null && result.data.cell_type !== '') {
                norm.cell_type = result.data.cell_type;
                hasCellType = true;
                cellTypesSet.add(result.data.cell_type);
              }
              
              if (norm.region) regionsSet.add(norm.region);
              if (norm.gene) genesSet.add(norm.gene);
              
              rawData.push(norm);
              rowCount++;
              
              // Update status less frequently
              if (rowCount % 100000 === 0) {
                requestAnimationFrame(() => {
                  document.getElementById('status').textContent = `Parsing CSV... (${rowCount.toLocaleString()} rows parsed)`;
                });
              }
            }
          },
          complete: function(results) {
            console.log('CSV parsing complete. Rows:', rawData.length, 'Errors:', results.errors);
            
            if (results.errors.length > 0) {
              console.warn('Parsing errors:', results.errors);
            }
            
            if (rawData.length === 0) {
              document.getElementById('status').textContent = 'Error: No data loaded from CSV file. The file may be empty or invalid.';
              document.getElementById('status').className = 'status error';
              document.getElementById('loading').style.display = 'none';
              return;
            }

            // Setup visualization with pre-extracted values
            setupVisualizationFast(Array.from(regionsSet), Array.from(genesSet), Array.from(cellTypesSet));
            document.getElementById('loading').style.display = 'none';
            document.getElementById('status').textContent = `Loaded ${rawData.length.toLocaleString()} records`;
            document.getElementById('status').className = 'status';
            // Hide status after a moment
            setTimeout(() => {
              if (document.getElementById('status').textContent.includes('Loaded')) {
                document.getElementById('status').style.display = 'none';
              }
            }, 2000);
          },
          error: function(error) {
            console.error('Error parsing CSV:', error);
            document.getElementById('status').textContent = 'Error: Failed to parse CSV file. ' + (error.message || 'Unknown error');
            document.getElementById('status').className = 'status error';
            document.getElementById('loading').style.display = 'none';
          }
        });
      };
      
      reader.onerror = function() {
        document.getElementById('status').textContent = 'Error: Failed to read file.';
        document.getElementById('status').className = 'status error';
        document.getElementById('loading').style.display = 'none';
      };
      
      // Read file as text
      reader.readAsText(file);
    }

    // Fast version that uses pre-extracted unique values
    function setupVisualizationFast(regions, genes, cellTypes) {
      // Sort the pre-extracted arrays
      regions = regions.filter(r => r).sort();
      genes = genes.filter(g => g).sort();
      cellTypes = cellTypes.filter(ct => ct).sort();
      
      setupVisualizationWithValues(regions, genes, cellTypes);
    }
    
    // Original version for backward compatibility
    function setupVisualization() {
      // Populate filters
      const regions = [...new Set(rawData.map(d => d.region))].filter(r => r).sort();
      const genes = [...new Set(rawData.map(d => d.gene))].filter(g => g).sort();
      
      // Populate cell_type filter if available
      let cellTypes = [];
      if (hasCellType) {
        cellTypes = [...new Set(rawData.map(d => d.cell_type))].filter(ct => ct).sort();
      }
      
      setupVisualizationWithValues(regions, genes, cellTypes);
    }
    
    function setupVisualizationWithValues(regions, genes, cellTypes) {
      
      // Create color scale for genes using D3's category20 color scheme
      // For more genes, cycle through multiple color schemes
      const colorSchemes = [
        d3.schemeCategory10,
        d3.schemeSet1,
        d3.schemeSet2,
        d3.schemeSet3,
        d3.schemePastel1,
        d3.schemePastel2,
        d3.schemeDark2,
        d3.schemeAccent
      ];
      
      // Flatten all color schemes into one array
      const allColors = colorSchemes.flat();
      
      // Create color scale - assign each gene a unique color
      colorScale = d3.scaleOrdinal()
        .domain(genes)
        .range(allColors);
      
      // Batch DOM updates using DocumentFragment for better performance
      const regionFragment = document.createDocumentFragment();
      regions.forEach(region => {
        const option = document.createElement('option');
        option.value = region;
        option.textContent = region;
        regionFragment.appendChild(option);
      });
      document.getElementById('regionFilter').appendChild(regionFragment);
      
      // Populate gene selector with checkboxes
      populateGeneSelector(genes);

      // Populate cell_type filter if available
      if (hasCellType && cellTypes.length > 0) {
        const cellTypeFragment = document.createDocumentFragment();
        cellTypes.forEach(cellType => {
          const option = document.createElement('option');
          option.value = cellType;
          option.textContent = cellType;
          cellTypeFragment.appendChild(option);
        });
        document.getElementById('cellTypeFilter').appendChild(cellTypeFragment);
        document.getElementById('cellTypeFilterGroup').style.display = 'flex';
      }

      // Update stats
      document.getElementById('totalRecords').textContent = rawData.length.toLocaleString();
      document.getElementById('uniqueGenes').textContent = genes.length;
      document.getElementById('uniqueRegions').textContent = regions.length;

      // Show stats
      document.getElementById('stats').style.display = 'flex';
      
      // Setup scales (shared across all visualizations)
      const xExtent = d3.extent(rawData, d => d.x_coordinate);
      const yExtent = d3.extent(rawData, d => d.y_coordinate);
      const zExtent = d3.extent(rawData, d => d.z_coordinate);
      
      // Store full extents for fixed axis ranges
      fullXExtent = xExtent;
      fullYExtent = yExtent;
      fullZExtent = zExtent;
      
      // Update zRange slider
      const zSlider = document.getElementById('zRange');
      zSlider.max = zExtent[1];
      zSlider.value = zExtent[1];
      document.getElementById('zRangeValue').textContent = zExtent[1].toFixed(1);

      // Setup Tab 1: 2D View
      setup2DView(xExtent, yExtent);
      
      // Setup Tab 2: 3D View
      setup3DView(xExtent, yExtent);
      
      // Setup Tab 3: Dashboard
      setupDashboard(xExtent, yExtent);

      // Update with initial data
      updateVisualization();
      
      // Legends removed - no need to create them
    }

    // Plotly 2D plot state
    let plotly2dInitialized = false;
    let plotly2dLayout = null;
    
    // Store full data extents for fixed axis ranges
    let fullXExtent = null;
    let fullYExtent = null;
    let fullZExtent = null;

    function setup2DView(xExtent, yExtent) {
      // Initialize Plotly 2D plot - actual data will be set in updatePlotly2D
      const plotlyDiv = document.getElementById('plotly2d');
      if (!plotlyDiv) return;
      
      // Store extents for later use
      plotly2dInitialized = true;
      
      // Initial empty plot to set up the scene
      const initialData = [{
        x: [],
        y: [],
        mode: 'markers',
        type: 'scattergl',
        marker: {
          size: 3,
          opacity: 0.6
        }
      }];
      
      plotly2dLayout = {
        xaxis: { 
          title: 'X [Î¼m]',
          showgrid: true,
          gridcolor: '#e0e0e0',
          range: fullXExtent ? [fullXExtent[0], fullXExtent[1]] : null,
          fixedrange: false // Allow zoom/pan but maintain base range
        },
        yaxis: { 
          title: 'Y [Î¼m]',
          showgrid: true,
          gridcolor: '#e0e0e0',
          range: fullYExtent ? [fullYExtent[0], fullYExtent[1]] : null,
          fixedrange: false // Allow zoom/pan but maintain base range
        },
        margin: { l: 60, r: 20, t: 20, b: 60 },
        paper_bgcolor: 'white',
        plot_bgcolor: 'white',
        showlegend: false,
        hovermode: 'closest'
      };
      
      const config = {
        displayModeBar: true,
        displaylogo: false,
        modeBarButtonsToRemove: ['lasso2d', 'select2d'],
        responsive: true
      };
      
      Plotly.newPlot('plotly2d', initialData, plotly2dLayout, config);
    }
    
    function updatePlotly2D() {
      if (!filteredData || filteredData.length === 0 || !colorScale) {
        return;
      }
      
      const plotlyDiv = document.getElementById('plotly2d');
      if (!plotlyDiv) return;
      
      // Initialize if not already done
      if (!plotly2dInitialized) {
        const xExtent = d3.extent(filteredData, d => d.x_coordinate);
        const yExtent = d3.extent(filteredData, d => d.y_coordinate);
        setup2DView(xExtent, yExtent);
      }
      
      const opacity = parseFloat(document.getElementById('opacityRange').value);
      const pointSize = parseFloat(document.getElementById('pointSize').value);
      
      // Group data by gene for color coding
      const genes = [...new Set(filteredData.map(d => d.gene))].filter(g => !hiddenGenes.has(g));
      
      // Sample data if too many points for better performance
      const maxPoints = 200000; // Scattergl can handle more points than scatter3d
      let dataToPlot = filteredData;
      if (filteredData.length > maxPoints) {
        // Use reservoir sampling for uniform random sampling
        dataToPlot = filteredData.slice(0, maxPoints);
        for (let i = maxPoints; i < filteredData.length; i++) {
          const j = Math.floor(Math.random() * (i + 1));
          if (j < maxPoints) {
            dataToPlot[j] = filteredData[i];
          }
        }
      }
      
      // Create traces for each gene
      const traces = [];
      genes.forEach(gene => {
        const geneData = dataToPlot.filter(d => d.gene === gene);
        if (geneData.length === 0) return;
        
        traces.push({
          x: geneData.map(d => d.x_coordinate),
          y: geneData.map(d => d.y_coordinate),
          mode: 'markers',
          type: 'scattergl',
          name: gene,
          showlegend: false,
          marker: {
            size: pointSize * 4, // Scale for Plotly (4x larger for better visibility)
            color: colorScale(gene),
            opacity: opacity,
            line: {
              width: 0.5,
              color: 'rgba(0, 0, 0, 0.3)'
            }
          },
          text: geneData.map(d => {
            let text = `Gene: ${d.gene}<br>Region: ${d.region}<br>Cell ID: ${d.cell_id}<br>Coordinates: (${d.x_coordinate.toFixed(2)}, ${d.y_coordinate.toFixed(2)}, ${d.z_coordinate.toFixed(2)})`;
            if (hasCellType && d.cell_type) {
              text += `<br>Cell Type: ${d.cell_type}`;
            }
            return text;
          }),
          hovertemplate: '<b>%{text}</b><extra></extra>'
        });
      });
      
      // Update plot with new data
      // Plotly.react preserves zoom/pan position automatically
      if (!plotly2dLayout) {
        // Fallback layout if not initialized
        plotly2dLayout = {
          xaxis: { 
            title: 'X [Î¼m]', 
            showgrid: true, 
            gridcolor: '#e0e0e0',
            range: fullXExtent ? [fullXExtent[0], fullXExtent[1]] : null,
            fixedrange: false
          },
          yaxis: { 
            title: 'Y [Î¼m]', 
            showgrid: true, 
            gridcolor: '#e0e0e0',
            range: fullYExtent ? [fullYExtent[0], fullYExtent[1]] : null,
            fixedrange: false
          },
          margin: { l: 60, r: 20, t: 20, b: 60 },
          paper_bgcolor: 'white',
          plot_bgcolor: 'white',
          showlegend: false,
          hovermode: 'closest'
        };
      }
      
      // Ensure legend is always hidden and ranges are preserved
      const layoutToUse = { 
        ...plotly2dLayout, 
        showlegend: false,
        xaxis: {
          ...plotly2dLayout.xaxis,
          range: fullXExtent ? [fullXExtent[0], fullXExtent[1]] : plotly2dLayout.xaxis.range
        },
        yaxis: {
          ...plotly2dLayout.yaxis,
          range: fullYExtent ? [fullYExtent[0], fullYExtent[1]] : plotly2dLayout.yaxis.range
        }
      };
      
      Plotly.react('plotly2d', traces, layoutToUse);
    }

    // Plotly 3D plot state
    let plotly3dInitialized = false;
    let plotly3dLayout = null;

    function setup3DView(xExtent, yExtent) {
      // Initialize Plotly 3D plot - actual data will be set in updatePlotly3D
      const plotlyDiv = document.getElementById('plotly3d');
      if (!plotlyDiv) return;
      
      // Store extents for later use
      plotly3dInitialized = true;
      
      // Initial empty plot to set up the scene
      const initialData = [{
        x: [],
        y: [],
        z: [],
        mode: 'markers',
        type: 'scatter3d',
        marker: {
          size: 2,
          opacity: 0.6
        }
      }];
      
      plotly3dLayout = {
        scene: {
          xaxis: { 
            title: 'X [Î¼m]',
            range: fullXExtent ? [fullXExtent[0], fullXExtent[1]] : null
          },
          yaxis: { 
            title: 'Y [Î¼m]',
            range: fullYExtent ? [fullYExtent[0], fullYExtent[1]] : null
          },
          zaxis: { 
            title: 'Z [Î¼m]',
            range: fullZExtent ? [fullZExtent[0], fullZExtent[1]] : null
          },
          camera: {
            eye: { x: 1.5, y: 1.5, z: 1.2 }
          }
        },
        margin: { l: 0, r: 0, t: 0, b: 0 },
        paper_bgcolor: 'white',
        plot_bgcolor: 'white',
        showlegend: false
      };
      
      const config = {
        displayModeBar: true,
        displaylogo: false,
        modeBarButtonsToRemove: ['lasso2d', 'select2d'],
        responsive: true
      };
      
      Plotly.newPlot('plotly3d', initialData, plotly3dLayout, config);
    }
    
    function updatePlotly3D() {
      if (!filteredData || filteredData.length === 0 || !colorScale) {
        return;
      }
      
      const plotlyDiv = document.getElementById('plotly3d');
      if (!plotlyDiv) return;
      
      // Initialize if not already done
      if (!plotly3dInitialized) {
        const xExtent = d3.extent(filteredData, d => d.x_coordinate);
        const yExtent = d3.extent(filteredData, d => d.y_coordinate);
        setup3DView(xExtent, yExtent);
      }
      
      const opacity = parseFloat(document.getElementById('opacityRange').value);
      const pointSize = parseFloat(document.getElementById('pointSize').value);
      
      // Group data by gene for color coding
      const genes = [...new Set(filteredData.map(d => d.gene))].filter(g => !hiddenGenes.has(g));
      
      // Sample data if too many points for better performance
      const maxPoints = 100000;
      let dataToPlot = filteredData;
      if (filteredData.length > maxPoints) {
        // Use reservoir sampling for uniform random sampling
        dataToPlot = filteredData.slice(0, maxPoints);
        for (let i = maxPoints; i < filteredData.length; i++) {
          const j = Math.floor(Math.random() * (i + 1));
          if (j < maxPoints) {
            dataToPlot[j] = filteredData[i];
          }
        }
      }
      
      // Create traces for each gene
      const traces = [];
      genes.forEach(gene => {
        const geneData = dataToPlot.filter(d => d.gene === gene);
        if (geneData.length === 0) return;
        
        traces.push({
          x: geneData.map(d => d.x_coordinate),
          y: geneData.map(d => d.y_coordinate),
          z: geneData.map(d => d.z_coordinate),
          mode: 'markers',
          type: 'scatter3d',
          name: gene,
          showlegend: false,
          marker: {
            size: pointSize * 4, // Scale for Plotly (4x larger for better visibility)
            color: colorScale(gene),
            opacity: opacity,
            line: {
              width: 0
            }
          },
          text: geneData.map(d => {
            let text = `Gene: ${d.gene}<br>Region: ${d.region}<br>Cell ID: ${d.cell_id}<br>Coordinates: (${d.x_coordinate.toFixed(2)}, ${d.y_coordinate.toFixed(2)}, ${d.z_coordinate.toFixed(2)})`;
            if (hasCellType && d.cell_type) {
              text += `<br>Cell Type: ${d.cell_type}`;
            }
            return text;
          }),
          hovertemplate: '<b>%{text}</b><extra></extra>'
        });
      });
      
      // Update plot with new data
      // Plotly.react preserves camera position automatically
      if (!plotly3dLayout) {
        // Fallback layout if not initialized
        plotly3dLayout = {
          scene: {
            xaxis: { 
              title: 'X [Î¼m]',
              range: fullXExtent ? [fullXExtent[0], fullXExtent[1]] : null
            },
            yaxis: { 
              title: 'Y [Î¼m]',
              range: fullYExtent ? [fullYExtent[0], fullYExtent[1]] : null
            },
            zaxis: { 
              title: 'Z [Î¼m]',
              range: fullZExtent ? [fullZExtent[0], fullZExtent[1]] : null
            },
            camera: { eye: { x: 1.5, y: 1.5, z: 1.2 } }
          },
          margin: { l: 0, r: 0, t: 0, b: 0 },
          paper_bgcolor: 'white',
          plot_bgcolor: 'white',
          showlegend: false
        };
      }
      
      // Ensure ranges are preserved
      const layoutToUse = {
        ...plotly3dLayout,
        scene: {
          ...plotly3dLayout.scene,
          xaxis: {
            ...plotly3dLayout.scene.xaxis,
            range: fullXExtent ? [fullXExtent[0], fullXExtent[1]] : plotly3dLayout.scene.xaxis.range
          },
          yaxis: {
            ...plotly3dLayout.scene.yaxis,
            range: fullYExtent ? [fullYExtent[0], fullYExtent[1]] : plotly3dLayout.scene.yaxis.range
          },
          zaxis: {
            ...plotly3dLayout.scene.zaxis,
            range: fullZExtent ? [fullZExtent[0], fullZExtent[1]] : plotly3dLayout.scene.zaxis.range
          }
        }
      };
      
      Plotly.react('plotly3d', traces, layoutToUse);
    }
    
    // Removed: setup3DControls function (Plotly handles 3D controls automatically)
    
    function draw3DAxes(ctxEl, xExtent, yExtent, zExtent, width, height) {
      if (!ctxEl || !xExtent || !yExtent || !zExtent) return;
      
      ctxEl.save();
      ctxEl.lineWidth = 2;
      ctxEl.font = '11px sans-serif';
      ctxEl.textAlign = 'center';
      ctxEl.textBaseline = 'middle';
      
      // Calculate center point (origin) in 3D space
      const centerX3D = (xExtent[0] + xExtent[1]) / 2;
      const centerY3D = (yExtent[0] + yExtent[1]) / 2;
      const centerZ3D = (zExtent[0] + zExtent[1]) / 2;
      
      // Project origin to screen
      const origin = project3D(centerX3D, centerY3D, centerZ3D, xExtent, yExtent, zExtent, width, height);
      
      // Generate tick values for each axis
      const xTicks = generateTicks(xExtent[0], xExtent[1], 5);
      const yTicks = generateTicks(yExtent[0], yExtent[1], 5);
      const zTicks = generateTicks(zExtent[0], zExtent[1], 5);
      
      // Draw X axis (red) - from origin to max X
      const xEnd = project3D(xExtent[1], centerY3D, centerZ3D, xExtent, yExtent, zExtent, width, height);
      ctxEl.strokeStyle = '#cc0000';
      ctxEl.lineWidth = 2;
      ctxEl.beginPath();
      ctxEl.moveTo(origin.x, origin.y);
      ctxEl.lineTo(xEnd.x, xEnd.y);
      ctxEl.stroke();
      
      // Draw X axis ticks and labels
      xTicks.forEach(tick => {
        const tickPos = project3D(tick, centerY3D, centerZ3D, xExtent, yExtent, zExtent, width, height);
        const dx = xEnd.x - origin.x;
        const dy = xEnd.y - origin.y;
        const len = Math.sqrt(dx * dx + dy * dy);
        const perpX = -dy / len * 5;
        const perpY = dx / len * 5;
        
        ctxEl.strokeStyle = '#cc0000';
        ctxEl.lineWidth = 1;
        ctxEl.beginPath();
        ctxEl.moveTo(tickPos.x - perpX, tickPos.y - perpY);
        ctxEl.lineTo(tickPos.x + perpX, tickPos.y + perpY);
        ctxEl.stroke();
        
        ctxEl.fillStyle = '#666';
        ctxEl.font = '10px sans-serif';
        ctxEl.textAlign = 'center';
        ctxEl.fillText(Math.round(tick).toString(), tickPos.x + perpX * 2, tickPos.y + perpY * 2);
      });
      
      // X axis label
      ctxEl.fillStyle = '#cc0000';
      ctxEl.font = 'bold 11px sans-serif';
      ctxEl.fillText('X Coordinate', xEnd.x + 20, xEnd.y);
      
      // Draw Y axis (green) - from origin to max Y
      const yEnd = project3D(centerX3D, yExtent[1], centerZ3D, xExtent, yExtent, zExtent, width, height);
      ctxEl.strokeStyle = '#00aa00';
      ctxEl.lineWidth = 2;
      ctxEl.beginPath();
      ctxEl.moveTo(origin.x, origin.y);
      ctxEl.lineTo(yEnd.x, yEnd.y);
      ctxEl.stroke();
      
      // Draw Y axis ticks and labels
      yTicks.forEach(tick => {
        const tickPos = project3D(centerX3D, tick, centerZ3D, xExtent, yExtent, zExtent, width, height);
        const dx = yEnd.x - origin.x;
        const dy = yEnd.y - origin.y;
        const len = Math.sqrt(dx * dx + dy * dy);
        const perpX = -dy / len * 5;
        const perpY = dx / len * 5;
        
        ctxEl.strokeStyle = '#00aa00';
        ctxEl.lineWidth = 1;
        ctxEl.beginPath();
        ctxEl.moveTo(tickPos.x - perpX, tickPos.y - perpY);
        ctxEl.lineTo(tickPos.x + perpX, tickPos.y + perpY);
        ctxEl.stroke();
        
        ctxEl.fillStyle = '#666';
        ctxEl.font = '10px sans-serif';
        ctxEl.fillText(Math.round(tick).toString(), tickPos.x + perpX * 2, tickPos.y + perpY * 2);
      });
      
      // Y axis label
      ctxEl.fillStyle = '#00aa00';
      ctxEl.font = 'bold 11px sans-serif';
      ctxEl.fillText('Y Coordinate', yEnd.x + 20, yEnd.y);
      
      // Draw Z axis (blue) - from origin to max Z
      const zEnd = project3D(centerX3D, centerY3D, zExtent[1], xExtent, yExtent, zExtent, width, height);
      ctxEl.strokeStyle = '#0000cc';
      ctxEl.lineWidth = 2;
      ctxEl.beginPath();
      ctxEl.moveTo(origin.x, origin.y);
      ctxEl.lineTo(zEnd.x, zEnd.y);
      ctxEl.stroke();
      
      // Draw Z axis ticks and labels
      zTicks.forEach(tick => {
        const tickPos = project3D(centerX3D, centerY3D, tick, xExtent, yExtent, zExtent, width, height);
        const dx = zEnd.x - origin.x;
        const dy = zEnd.y - origin.y;
        const len = Math.sqrt(dx * dx + dy * dy);
        const perpX = -dy / len * 5;
        const perpY = dx / len * 5;
        
        ctxEl.strokeStyle = '#0000cc';
        ctxEl.lineWidth = 1;
        ctxEl.beginPath();
        ctxEl.moveTo(tickPos.x - perpX, tickPos.y - perpY);
        ctxEl.lineTo(tickPos.x + perpX, tickPos.y + perpY);
        ctxEl.stroke();
        
        ctxEl.fillStyle = '#666';
        ctxEl.font = '10px sans-serif';
        ctxEl.fillText(Math.round(tick).toString(), tickPos.x + perpX * 2, tickPos.y + perpY * 2);
      });
      
      // Z axis label
      ctxEl.fillStyle = '#0000cc';
      ctxEl.font = 'bold 11px sans-serif';
      ctxEl.fillText('Z Coordinate', zEnd.x + 20, zEnd.y);
      
      // Draw origin point
      ctxEl.fillStyle = '#000';
      ctxEl.beginPath();
      ctxEl.arc(origin.x, origin.y, 4, 0, Math.PI * 2);
      ctxEl.fill();
      
      ctxEl.restore();
    }
    
    function generateTicks(min, max, count) {
      const ticks = [];
      const range = max - min;
      // Use nice round numbers
      const niceRange = niceNumber(range);
      const niceStep = niceRange / (count - 1);
      const niceMin = Math.floor(min / niceStep) * niceStep;
      
      for (let i = 0; i < count; i++) {
        const tick = niceMin + niceStep * i;
        if (tick >= min && tick <= max) {
          ticks.push(tick);
        }
      }
      
      // Always include min and max
      if (ticks.length === 0 || ticks[0] !== min) ticks.unshift(min);
      if (ticks[ticks.length - 1] !== max) ticks.push(max);
      
      return ticks;
    }
    
    function niceNumber(range) {
      const exponent = Math.floor(Math.log10(range));
      const fraction = range / Math.pow(10, exponent);
      let niceFraction;
      
      if (fraction <= 1) niceFraction = 1;
      else if (fraction <= 2) niceFraction = 2;
      else if (fraction <= 5) niceFraction = 5;
      else niceFraction = 10;
      
      return niceFraction * Math.pow(10, exponent);
    }

    // Dashboard canvas state
    let dashboard2dCanvas, dashboard2dCtx, dashboard2dAxesSvg, dashboard2dXScale, dashboard2dYScale;
    let dashboard3dCanvas, dashboard3dCtx, dashboard3dAxesSvg, dashboard3dXScale, dashboard3dYScale;

    function setupDashboard(xExtent, yExtent) {
      // Setup dashboard 2D view (first, left side)
      const dashboard2dCell = document.getElementById('dashboard2d').parentElement;
      const dashboard2dRect = dashboard2dCell.getBoundingClientRect();
      const dashboard2dWidth = dashboard2dRect.width || 300;
      const dashboard2dHeight = dashboard2dRect.height || 200;
      
      dashboard2dCanvas = document.getElementById('dashboard2d');
      dashboard2dCanvas.width = dashboard2dWidth;
      dashboard2dCanvas.height = dashboard2dHeight;
      dashboard2dCanvas.style.width = dashboard2dWidth + 'px';
      dashboard2dCanvas.style.height = dashboard2dHeight + 'px';
      
      // Enable anti-aliasing for better quality
      dashboard2dCtx = dashboard2dCanvas.getContext('2d', { 
        antialias: true,
        alpha: true 
      });
      
      // Improve rendering quality
      dashboard2dCtx.imageSmoothingEnabled = true;
      dashboard2dCtx.imageSmoothingQuality = 'high';
      
      dashboard2dAxesSvg = d3.select('#dashboard2dAxes')
        .attr('width', dashboard2dWidth)
        .attr('height', dashboard2dHeight)
        .style('width', dashboard2dWidth + 'px')
        .style('height', dashboard2dHeight + 'px');
      
      dashboard2dXScale = d3.scaleLinear()
        .domain(xExtent)
        .range([margin.left, dashboard2dWidth - margin.right]);

      dashboard2dYScale = d3.scaleLinear()
        .domain(yExtent)
        .range([dashboard2dHeight - margin.bottom, margin.top]);

      // Setup dashboard 3D view (second, right side)
      const dashboard3dCell = document.getElementById('dashboard3d').parentElement;
      const dashboard3dRect = dashboard3dCell.getBoundingClientRect();
      const dashboard3dWidth = dashboard3dRect.width || 300;
      const dashboard3dHeight = dashboard3dRect.height || 200;
      
      dashboard3dCanvas = document.getElementById('dashboard3d');
      dashboard3dCanvas.width = dashboard3dWidth;
      dashboard3dCanvas.height = dashboard3dHeight;
      dashboard3dCanvas.style.width = dashboard3dWidth + 'px';
      dashboard3dCanvas.style.height = dashboard3dHeight + 'px';
      
      // Enable anti-aliasing for better quality
      dashboard3dCtx = dashboard3dCanvas.getContext('2d', { 
        antialias: true,
        alpha: true 
      });
      
      // Improve rendering quality
      dashboard3dCtx.imageSmoothingEnabled = true;
      dashboard3dCtx.imageSmoothingQuality = 'high';
      
      dashboard3dAxesSvg = d3.select('#dashboard3dAxes')
        .attr('width', dashboard3dWidth)
        .attr('height', dashboard3dHeight)
        .style('width', dashboard3dWidth + 'px')
        .style('height', dashboard3dHeight + 'px');
      
      dashboard3dXScale = d3.scaleLinear()
        .domain(xExtent)
        .range([margin.left, dashboard3dWidth - margin.right]);

      dashboard3dYScale = d3.scaleLinear()
        .domain(yExtent)
        .range([dashboard3dHeight - margin.bottom, margin.top]);
    }

    function updateLegendHeight() {
      const legend = document.getElementById('legend');
      const canvas = document.getElementById('scatterplot');
      if (legend && canvas && canvas.style.height) {
        // Match legend height to canvas height dynamically
        const canvasHeight = canvas.height || parseInt(canvas.style.height) || 400;
        legend.style.height = canvasHeight + 'px';
        legend.style.maxHeight = canvasHeight + 'px';
      }
    }

    function createLegend(genes, legendId = 'legend', legendItemsId = 'legendItems') {
      const legendContainer = document.getElementById(legendId);
      const legendItems = document.getElementById(legendItemsId);
      if (!legendContainer || !legendItems) return;
      
      legendItems.innerHTML = '';
      
      if (!colorScale || genes.length === 0) {
        legendContainer.style.display = 'none';
        return;
      }
      
      // Show legend only if it's for the active tab
      if (legendId === 'legend2d' && currentTab === 1) {
        legendContainer.style.display = 'block';
      } else if (legendId === 'legend3d' && currentTab === 2) {
        legendContainer.style.display = 'block';
      } else if (legendId === 'legend2d' || legendId === 'legend3d') {
        legendContainer.style.display = 'none';
      } else {
        legendContainer.style.display = 'block';
      }
      
      // Create legend items for each gene
      genes.forEach(gene => {
        const item = document.createElement('div');
        item.className = 'legend-item';
        item.innerHTML = `
          <div class="legend-color" style="background-color: ${colorScale(gene)};"></div>
          <span class="legend-label">${gene}</span>
        `;
        
        // Add click handler to toggle gene visibility
        item.addEventListener('click', function() {
          const isHidden = item.classList.contains('hidden');
          
          // Update all legends to keep them in sync
          document.querySelectorAll('.legend-item').forEach(li => {
            const label = li.querySelector('.legend-label');
            if (label && label.textContent.trim() === gene) {
              if (isHidden) {
                li.classList.remove('hidden');
              } else {
                li.classList.add('hidden');
              }
            }
          });
          
          updateVisualization();
        });
        
        legendItems.appendChild(item);
      });
    }

    // Sample data for performance
    function sampleData(data, maxPoints) {
      if (data.length <= maxPoints) {
        return data;
      }
      // Use reservoir sampling for uniform random sampling
      const sampled = data.slice(0, maxPoints);
      for (let i = maxPoints; i < data.length; i++) {
        const j = Math.floor(Math.random() * (i + 1));
        if (j < maxPoints) {
          sampled[j] = data[i];
        }
      }
      return sampled;
    }

    let hoverTimeout = null;
    let lastHoveredPoint = null;
    // Removed: canvasInteractivitySetup2d, canvasInteractivitySetup3d (only used for dashboard now)
    let dashboardInteractivitySetup = new Set();
    
    function setupCanvasInteractivity(canvasEl, xScaleEl, yScaleEl, is2d = true) {
      // Only used for dashboard views now (main 2D/3D use Plotly)
      if (!canvasEl) return;
      const canvasId = canvasEl.id;
      if (dashboardInteractivitySetup.has(canvasId)) return;
      dashboardInteractivitySetup.add(canvasId);
      
      canvasEl.addEventListener('mousemove', function(event) {
        // Don't show tooltip if dragging or panning
        // Note: isDragging/isPanning only apply to dashboard 3D view now
        if (isDragging || isPanning) {
          if (hoverTimeout) {
            clearTimeout(hoverTimeout);
            hoverTimeout = null;
          }
          document.getElementById('tooltip').style.display = 'none';
          return;
        }
        
        if (!filteredData || filteredData.length === 0 || !xScaleEl || !yScaleEl) return;
        
        // Throttle hover detection for performance
        if (hoverTimeout) {
          clearTimeout(hoverTimeout);
        }
        
        hoverTimeout = setTimeout(() => {
          const rect = canvasEl.getBoundingClientRect();
          const x = event.clientX - rect.left;
          const y = event.clientY - rect.top;
          
          // Find nearest point (within reasonable distance)
          const pointSize = parseFloat(document.getElementById('pointSize').value);
          const searchRadius = pointSize * 4;
          const searchRadiusSq = searchRadius * searchRadius;
          
          let nearestPoint = null;
          let minDistSq = searchRadiusSq;
          
          const renderedData = window.renderedData || [];
          const maxSearch = Math.min(renderedData.length, 50000);
          
          // Check if this is 3D view
          const is3DView = !is2d;
          let xExtent, yExtent, zExtent;
          if (is3DView && filteredData && filteredData.length > 0) {
            xExtent = d3.extent(filteredData, d => d.x_coordinate);
            yExtent = d3.extent(filteredData, d => d.y_coordinate);
            zExtent = d3.extent(filteredData, d => d.z_coordinate);
          }
          
          for (let i = 0; i < maxSearch; i++) {
            const d = renderedData[i];
            let px, py;
            if (is3DView && xExtent && yExtent && zExtent) {
              const proj = project3D(d.x_coordinate, d.y_coordinate, d.z_coordinate,
                                    xExtent, yExtent, zExtent, canvasEl.width, canvasEl.height);
              px = proj.x;
              py = proj.y;
            } else {
              px = xScaleEl(d.x_coordinate);
              py = yScaleEl(d.y_coordinate);
            }
            const dx = x - px;
            const dy = y - py;
            const distSq = dx * dx + dy * dy;
            
            if (distSq < minDistSq) {
              minDistSq = distSq;
              nearestPoint = d;
            }
          }
          
          if (nearestPoint !== lastHoveredPoint) {
            lastHoveredPoint = nearestPoint;
            hoveredPoint = nearestPoint;
            
            const tooltip = document.getElementById('tooltip');
            if (nearestPoint) {
              let tooltipHtml = `
                <strong>Gene:</strong> ${nearestPoint.gene}<br>
                <strong>Region:</strong> ${nearestPoint.region}<br>
                <strong>Cell ID:</strong> ${nearestPoint.cell_id}<br>
                <strong>Coordinates:</strong> (${nearestPoint.x_coordinate.toFixed(2)}, ${nearestPoint.y_coordinate.toFixed(2)}, ${nearestPoint.z_coordinate.toFixed(2)})
              `;
              if (hasCellType && nearestPoint.cell_type) {
                tooltipHtml += `<br><strong>Cell Type:</strong> ${nearestPoint.cell_type}`;
              }
              tooltip.innerHTML = tooltipHtml;
              tooltip.style.display = 'block';
              tooltip.style.left = (event.pageX + 10) + 'px';
              tooltip.style.top = (event.pageY - 10) + 'px';
              
              updateVisualization();
            } else {
              tooltip.style.display = 'none';
              hoveredPoint = null;
              updateVisualization();
            }
          } else if (nearestPoint) {
            const tooltip = document.getElementById('tooltip');
            tooltip.style.left = (event.pageX + 10) + 'px';
            tooltip.style.top = (event.pageY - 10) + 'px';
          }
        }, 50);
      });
      
      canvasEl.addEventListener('mouseout', function() {
        if (hoverTimeout) {
          clearTimeout(hoverTimeout);
          hoverTimeout = null;
        }
        document.getElementById('tooltip').style.display = 'none';
        hoveredPoint = null;
        lastHoveredPoint = null;
        updateVisualization();
      });
    }

    // 3D projection function with rotation
    function project3D(x, y, z, xExtent, yExtent, zExtent, width, height, useRotation = true) {
      // Normalize coordinates to 0-1 range, then scale to -1 to 1
      const nx = (xExtent[1] - xExtent[0]) > 0 ? (x - xExtent[0]) / (xExtent[1] - xExtent[0]) : 0.5;
      const ny = (yExtent[1] - yExtent[0]) > 0 ? (y - yExtent[0]) / (yExtent[1] - yExtent[0]) : 0.5;
      const nz = (zExtent[1] - zExtent[0]) > 0 ? (z - zExtent[0]) / (zExtent[1] - zExtent[0]) : 0.5;
      
      // Convert to -1 to 1 range (centered)
      let px = (nx - 0.5) * 2;
      let py = (ny - 0.5) * 2;
      let pz = (nz - 0.5) * 2;
      
      if (useRotation) {
        // Apply rotation around Y axis (horizontal rotation)
        const cosY = Math.cos(rotationY);
        const sinY = Math.sin(rotationY);
        const tempX = px * cosY - pz * sinY;
        pz = px * sinY + pz * cosY;
        px = tempX;
        
        // Apply rotation around X axis (vertical rotation)
        const cosX = Math.cos(rotationX);
        const sinX = Math.sin(rotationX);
        const tempY = py * cosX - pz * sinX;
        pz = py * sinX + pz * cosX;
        py = tempY;
      }
      
      // Scale to canvas with margins and apply pan
      const margin = { top: 30, right: 30, bottom: 45, left: 45 };
      const plotWidth = width - margin.left - margin.right;
      const plotHeight = height - margin.top - margin.bottom;
      
      // Project to 2D (orthographic projection)
      const scale = Math.min(plotWidth, plotHeight) * 0.4; // Scale factor
      const screenX = margin.left + plotWidth / 2 + px * scale + panX;
      const screenY = margin.top + plotHeight / 2 - py * scale + panY; // Flip Y for screen coordinates
      
      // Calculate depth for opacity (normalized Z after rotation)
      const depth = (pz + 1) / 2; // Normalize to 0-1
      
      return { x: screenX, y: screenY, depth: depth };
    }

    function renderPoints(canvasEl, ctxEl, xScaleEl, yScaleEl, highlightPoint = null, is3D = false) {
      if (!canvasEl || !ctxEl || !filteredData || filteredData.length === 0 || !colorScale || !xScaleEl || !yScaleEl) {
        return;
      }

      const opacity = parseFloat(document.getElementById('opacityRange').value);
      const pointSize = parseFloat(document.getElementById('pointSize').value);

      // Clear canvas
      ctxEl.clearRect(0, 0, canvasEl.width, canvasEl.height);
      
      // Get extents for 3D projection
      let xExtent, yExtent, zExtent;
      if (is3D) {
        xExtent = d3.extent(filteredData, d => d.x_coordinate);
        yExtent = d3.extent(filteredData, d => d.y_coordinate);
        zExtent = d3.extent(filteredData, d => d.z_coordinate);
        
        // Draw 3D axes before points (so axes are behind points)
        draw3DAxes(ctxEl, xExtent, yExtent, zExtent, canvasEl.width, canvasEl.height);
      }
      
      // Sample data if too many points
      const dataToRender = sampleData(filteredData, MAX_POINTS_TO_RENDER);
      // Store rendered data for dashboard mouse interaction
      if (canvasEl.id === 'dashboard2d' || canvasEl.id === 'dashboard3d') {
        window.renderedData = dataToRender;
      }
      
      // Render points on canvas
      ctxEl.save();
      ctxEl.globalAlpha = opacity;
      
      // For 3D, sort by depth (Z) so far points render first
      let sortedData = dataToRender;
      if (is3D) {
        sortedData = [...dataToRender].sort((a, b) => b.z_coordinate - a.z_coordinate);
      }
      
      // Group by color for better performance
      const pointsByColor = {};
      sortedData.forEach(d => {
        const color = colorScale(d.gene);
        if (!pointsByColor[color]) {
          pointsByColor[color] = [];
        }
        pointsByColor[color].push(d);
      });
      
      // Render each color group
      if (pointSize <= 2) {
        // For small points, use rectangles (much faster)
        Object.keys(pointsByColor).forEach(color => {
          pointsByColor[color].forEach(d => {
            let x, y, pointOpacity = opacity;
            if (is3D) {
              const proj = project3D(d.x_coordinate, d.y_coordinate, d.z_coordinate, 
                                    xExtent, yExtent, zExtent, canvasEl.width, canvasEl.height);
              x = proj.x - pointSize;
              y = proj.y - pointSize;
              // Adjust opacity based on depth for 3D effect (farther = more transparent)
              pointOpacity = opacity * (0.4 + 0.6 * proj.depth);
            } else {
              x = xScaleEl(d.x_coordinate) - pointSize;
              y = yScaleEl(d.y_coordinate) - pointSize;
            }
            ctxEl.save();
            ctxEl.globalAlpha = pointOpacity;
            ctxEl.fillStyle = color;
            ctxEl.fillRect(x, y, pointSize * 2, pointSize * 2);
            ctxEl.restore();
          });
        });
      } else {
        // For larger points, use circles - render individually to control opacity per point
        Object.keys(pointsByColor).forEach(color => {
          pointsByColor[color].forEach(d => {
            let x, y, pointOpacity = opacity;
            if (is3D) {
              const proj = project3D(d.x_coordinate, d.y_coordinate, d.z_coordinate,
                                    xExtent, yExtent, zExtent, canvasEl.width, canvasEl.height);
              x = proj.x;
              y = proj.y;
              // Adjust opacity based on depth for 3D effect (farther = more transparent)
              pointOpacity = opacity * (0.4 + 0.6 * proj.depth);
            } else {
              x = xScaleEl(d.x_coordinate);
              y = yScaleEl(d.y_coordinate);
            }
            ctxEl.save();
            ctxEl.globalAlpha = pointOpacity;
            ctxEl.fillStyle = color;
            ctxEl.beginPath();
            ctxEl.arc(x, y, pointSize, 0, Math.PI * 2);
            ctxEl.fill();
            ctxEl.restore();
          });
        });
      }
      
      // Highlight hovered point if any
      if (highlightPoint) {
        ctxEl.globalAlpha = 1;
        ctxEl.fillStyle = colorScale(highlightPoint.gene);
        ctxEl.beginPath();
        let hx, hy;
        if (is3D) {
          const proj = project3D(highlightPoint.x_coordinate, highlightPoint.y_coordinate, highlightPoint.z_coordinate,
                                xExtent, yExtent, zExtent, canvasEl.width, canvasEl.height);
          hx = proj.x;
          hy = proj.y;
        } else {
          hx = xScaleEl(highlightPoint.x_coordinate);
          hy = yScaleEl(highlightPoint.y_coordinate);
        }
        ctxEl.arc(hx, hy, pointSize * 2, 0, Math.PI * 2);
        ctxEl.fill();
      }
      
      ctxEl.restore();
    }

    // Gene Selector Functions
    function populateGeneSelector(genes) {
      const list = document.getElementById('geneSelectorList');
      if (!list) return;
      
      list.innerHTML = '';
      hiddenGenes.clear(); // Reset hidden genes when loading new data
      
      genes.forEach(gene => {
        const item = document.createElement('div');
        item.className = 'gene-checkbox-item';
        // Escape gene name for use in ID and HTML
        const geneId = 'gene-' + gene.replace(/[^a-zA-Z0-9]/g, '_');
        item.innerHTML = `
          <input type="checkbox" class="gene-checkbox" id="${geneId}" checked data-gene="${gene.replace(/"/g, '&quot;')}">
          <label class="gene-checkbox-label" for="${geneId}">${gene}</label>
        `;
        // Add event listener to avoid inline handlers with special characters
        const checkbox = item.querySelector('.gene-checkbox');
        checkbox.addEventListener('change', function() {
          toggleGene(gene);
        });
        list.appendChild(item);
      });
      
      updateGeneSelectorButton();
    }

    function toggleGene(gene) {
      // Find checkbox by data-gene attribute to handle special characters
      const checkbox = document.querySelector(`.gene-checkbox[data-gene="${gene.replace(/"/g, '&quot;')}"]`);
      if (!checkbox) return;
      
      const item = checkbox.closest('.gene-checkbox-item');
      
      if (checkbox.checked) {
        hiddenGenes.delete(gene);
        if (item) item.classList.remove('hidden');
      } else {
        hiddenGenes.add(gene);
        if (item) item.classList.add('hidden');
      }
      
      updateGeneSelectorButton();
      updateVisualization();
    }

    function hideAllGenes() {
      const checkboxes = document.querySelectorAll('.gene-checkbox');
      checkboxes.forEach(checkbox => {
        checkbox.checked = false;
        const gene = checkbox.getAttribute('data-gene');
        if (gene) {
          hiddenGenes.add(gene);
          const item = checkbox.closest('.gene-checkbox-item');
          if (item) item.classList.add('hidden');
        }
      });
      updateGeneSelectorButton();
      updateVisualization();
    }

    function showAllGenes() {
      const checkboxes = document.querySelectorAll('.gene-checkbox');
      checkboxes.forEach(checkbox => {
        checkbox.checked = true;
        const gene = checkbox.getAttribute('data-gene');
        if (gene) {
          hiddenGenes.delete(gene);
          const item = checkbox.closest('.gene-checkbox-item');
          if (item) item.classList.remove('hidden');
        }
      });
      updateGeneSelectorButton();
      updateVisualization();
    }

    function toggleGeneSelector() {
      const dropdown = document.getElementById('geneSelectorDropdown');
      const button = document.getElementById('geneSelectorButton');
      
      if (dropdown.style.display === 'none') {
        dropdown.style.display = 'flex';
        button.classList.add('open');
      } else {
        dropdown.style.display = 'none';
        button.classList.remove('open');
      }
    }

    function filterGeneList() {
      const searchTerm = document.getElementById('geneSearchInput').value.toLowerCase();
      const items = document.querySelectorAll('.gene-checkbox-item');
      
      items.forEach(item => {
        const label = item.querySelector('.gene-checkbox-label');
        const geneName = label.textContent.toLowerCase();
        if (geneName.includes(searchTerm)) {
          item.style.display = 'flex';
        } else {
          item.style.display = 'none';
        }
      });
    }

    function updateGeneSelectorButton() {
      const button = document.getElementById('geneSelectorText');
      if (!button) return;
      
      const totalGenes = document.querySelectorAll('.gene-checkbox').length;
      if (totalGenes === 0) {
        button.textContent = 'All Genes';
        return;
      }
      
      const hiddenCount = hiddenGenes.size;
      const visibleCount = totalGenes - hiddenCount;
      
      if (hiddenCount === 0) {
        button.textContent = 'All Genes';
      } else if (hiddenCount === totalGenes) {
        button.textContent = 'No Genes';
      } else {
        button.textContent = `${visibleCount} of ${totalGenes} Genes`;
      }
    }

    // Close dropdown when clicking outside
    document.addEventListener('click', function(event) {
      const container = document.querySelector('.gene-selector-container');
      const dropdown = document.getElementById('geneSelectorDropdown');
      
      if (container && dropdown && !container.contains(event.target)) {
        dropdown.style.display = 'none';
        document.getElementById('geneSelectorButton').classList.remove('open');
      }
    });

    function updateCellTypeFilter() {
      if (!hasCellType || !rawData || rawData.length === 0) {
        return;
      }
      
      const regionFilter = document.getElementById('regionFilter').value;
      const cellTypeFilterEl = document.getElementById('cellTypeFilter');
      const currentSelection = cellTypeFilterEl.value;
      
      // Get available cell types based on current region filter
      let availableCellTypes;
      if (regionFilter) {
        // Filter by selected region
        availableCellTypes = [...new Set(
          rawData
            .filter(d => d.region === regionFilter && d.cell_type)
            .map(d => d.cell_type)
        )].filter(ct => ct).sort();
      } else {
        // Show all cell types if no region filter
        availableCellTypes = [...new Set(
          rawData
            .filter(d => d.cell_type)
            .map(d => d.cell_type)
        )].filter(ct => ct).sort();
      }
      
      // Update dropdown options
      cellTypeFilterEl.innerHTML = '<option value="">All Cell Types</option>';
      availableCellTypes.forEach(cellType => {
        const option = document.createElement('option');
        option.value = cellType;
        option.textContent = cellType;
        cellTypeFilterEl.appendChild(option);
      });
      
      // Restore previous selection if it's still valid, otherwise reset to "All"
      if (currentSelection && availableCellTypes.includes(currentSelection)) {
        cellTypeFilterEl.value = currentSelection;
      } else {
        cellTypeFilterEl.value = '';
      }
    }

    function updateVisualization() {
      if (!rawData || rawData.length === 0 || !colorScale) {
        return;
      }

      const regionFilter = document.getElementById('regionFilter').value;
      const cellTypeFilter = document.getElementById('cellTypeFilter').value;
      const zMax = parseFloat(document.getElementById('zRange').value);
      const opacity = parseFloat(document.getElementById('opacityRange').value);
      const pointSize = parseFloat(document.getElementById('pointSize').value);

      // Filter data (hiddenGenes is tracked in global Set)
      filteredData = rawData.filter(d => {
        const regionMatch = !regionFilter || d.region === regionFilter;
        const cellTypeMatch = !hasCellType || !cellTypeFilter || d.cell_type === cellTypeFilter;
        const zMatch = d.z_coordinate <= zMax;
        const notHidden = !hiddenGenes.has(d.gene);
        return regionMatch && cellTypeMatch && zMatch && notHidden;
      });

      // Update visible points count
      const totalPoints = filteredData.length;
      const pointsToRender = Math.min(totalPoints, MAX_POINTS_TO_RENDER);
      if (pointsToRender < totalPoints) {
        document.getElementById('visiblePoints').textContent = `${pointsToRender.toLocaleString()} of ${totalPoints.toLocaleString()} (sampled)`;
      } else {
        document.getElementById('visiblePoints').textContent = totalPoints.toLocaleString();
      }

      // Debounce rendering for smooth slider interactions
      if (renderTimeout) {
        clearTimeout(renderTimeout);
      }
      
      renderTimeout = setTimeout(() => {
        // Always render both 2D and 3D views (they're independent)
        // Update Plotly 2D plot (will initialize if needed)
        if (currentTab === 1 && filteredData && filteredData.length > 0) {
          updatePlotly2D();
        }
        // Update Plotly 3D plot (will initialize if needed)
        if (currentTab === 2 && filteredData && filteredData.length > 0) {
          updatePlotly3D();
        }
        
        // Always update dashboard if tab 3 is active
        if (currentTab === 3) {
          updateDashboard();
        }
        
        renderTimeout = null;
      }, 16); // ~60fps
    }

    function updateDashboard() {
      if (!filteredData || filteredData.length === 0) return;
      
      // Render dashboard 2D and 3D views (order: 2D first, then 3D)
      if (dashboard2dCanvas && dashboard2dCtx && dashboard2dXScale && dashboard2dYScale) {
        renderPoints(dashboard2dCanvas, dashboard2dCtx, dashboard2dXScale, dashboard2dYScale, null, false);
      }
      if (dashboard3dCanvas && dashboard3dCtx && dashboard3dXScale && dashboard3dYScale) {
        renderPoints(dashboard3dCanvas, dashboard3dCtx, dashboard3dXScale, dashboard3dYScale, null, true);
      }
      
      // Update all dashboard charts
      updateSummaryTable();
      updateGeneExpressionChart();
      updateRegionHeatmap();
      updateZSliceChart();
      updateCellTypeChart();
      updateSpatialDensityChart();
      updateExpressionViolinChart();
    }

    function updateSummaryTable() {
      const tableContainer = document.getElementById('summaryTable');
      if (!tableContainer || !filteredData || filteredData.length === 0) return;
      
      // Calculate statistics by region
      const regionStats = {};
      filteredData.forEach(d => {
        if (!regionStats[d.region]) {
          regionStats[d.region] = {
            totalPoints: 0,
            uniqueGenes: new Set(),
            uniqueCells: new Set()
          };
        }
        regionStats[d.region].totalPoints++;
        regionStats[d.region].uniqueGenes.add(d.gene);
        regionStats[d.region].uniqueCells.add(d.cell_id);
      });
      
      let tableHtml = '<table class="summary-table"><thead><tr><th>Region</th><th>Points</th><th>Genes</th><th>Cells</th></tr></thead><tbody>';
      Object.keys(regionStats).sort().forEach(region => {
        const stats = regionStats[region];
        tableHtml += `<tr><td>${region}</td><td>${stats.totalPoints.toLocaleString()}</td><td>${stats.uniqueGenes.size}</td><td>${stats.uniqueCells.size}</td></tr>`;
      });
      tableHtml += '</tbody></table>';
      tableContainer.innerHTML = tableHtml;
    }

    function updateGeneExpressionChart() {
      const svg = d3.select('#geneExpressionChart');
      if (svg.empty() || !filteredData || filteredData.length === 0) return;
      
      svg.selectAll('*').remove();
      
      const width = svg.node().getBoundingClientRect().width || 300;
      const height = svg.node().getBoundingClientRect().height || 200;
      const margin = { top: 20, right: 20, bottom: 30, left: 40 };
      const chartWidth = width - margin.left - margin.right;
      const chartHeight = height - margin.top - margin.bottom;
      
      // Count gene occurrences
      const geneCounts = {};
      filteredData.forEach(d => {
        geneCounts[d.gene] = (geneCounts[d.gene] || 0) + 1;
      });
      
      const data = Object.entries(geneCounts).map(([gene, count]) => ({ gene, count })).sort((a, b) => b.count - a.count).slice(0, 20);
      
      const xScale = d3.scaleBand()
        .domain(data.map(d => d.gene))
        .range([0, chartWidth])
        .padding(0.1);
      
      const yScale = d3.scaleLinear()
        .domain([0, d3.max(data, d => d.count)])
        .range([chartHeight, 0]);
      
      const g = svg.append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);
      
      g.append('g')
        .attr('transform', `translate(0,${chartHeight})`)
        .call(d3.axisBottom(xScale))
        .selectAll('text')
        .attr('transform', 'rotate(-45)')
        .style('text-anchor', 'end')
        .style('font-size', '8px');
      
      g.append('g')
        .call(d3.axisLeft(yScale))
        .style('font-size', '8px');
      
      g.selectAll('.bar')
        .data(data)
        .enter().append('rect')
        .attr('class', 'bar')
        .attr('x', d => xScale(d.gene))
        .attr('width', xScale.bandwidth())
        .attr('y', d => yScale(d.count))
        .attr('height', d => chartHeight - yScale(d.count))
        .attr('fill', d => colorScale(d.gene));
    }

    function updateRegionHeatmap() {
      const svg = d3.select('#regionHeatmap');
      if (svg.empty() || !filteredData || filteredData.length === 0) return;
      
      svg.selectAll('*').remove();
      
      const width = svg.node().getBoundingClientRect().width || 300;
      const height = svg.node().getBoundingClientRect().height || 200;
      const margin = { top: 40, right: 20, bottom: 40, left: 100 };
      const chartWidth = width - margin.left - margin.right;
      const chartHeight = height - margin.top - margin.bottom;
      
      // Calculate gene expression by region
      const regionGeneCounts = {};
      filteredData.forEach(d => {
        if (!regionGeneCounts[d.region]) {
          regionGeneCounts[d.region] = {};
        }
        regionGeneCounts[d.region][d.gene] = (regionGeneCounts[d.region][d.gene] || 0) + 1;
      });
      
      const regions = Object.keys(regionGeneCounts).sort();
      const allGenes = [...new Set(filteredData.map(d => d.gene))].sort().slice(0, 15);
      
      const data = [];
      regions.forEach(region => {
        allGenes.forEach(gene => {
          data.push({
            region,
            gene,
            count: regionGeneCounts[region][gene] || 0
          });
        });
      });
      
      const maxCount = d3.max(data, d => d.count);
      const colorScaleHeat = d3.scaleSequential(d3.interpolateBlues)
        .domain([0, maxCount]);
      
      const xScale = d3.scaleBand()
        .domain(allGenes)
        .range([0, chartWidth])
        .padding(0.05);
      
      const yScale = d3.scaleBand()
        .domain(regions)
        .range([0, chartHeight])
        .padding(0.05);
      
      const g = svg.append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);
      
      g.selectAll('.cell')
        .data(data)
        .enter().append('rect')
        .attr('class', 'cell')
        .attr('x', d => xScale(d.gene))
        .attr('y', d => yScale(d.region))
        .attr('width', xScale.bandwidth())
        .attr('height', yScale.bandwidth())
        .attr('fill', d => colorScaleHeat(d.count))
        .attr('stroke', '#fff')
        .attr('stroke-width', 0.5);
      
      g.append('g')
        .attr('transform', `translate(0,${chartHeight})`)
        .call(d3.axisBottom(xScale))
        .selectAll('text')
        .attr('transform', 'rotate(-45)')
        .style('text-anchor', 'end')
        .style('font-size', '7px');
      
      g.append('g')
        .call(d3.axisLeft(yScale))
        .style('font-size', '8px');
    }

    function updateZSliceChart() {
      const svg = d3.select('#zSliceChart');
      if (svg.empty() || !filteredData || filteredData.length === 0) return;
      
      svg.selectAll('*').remove();
      
      const width = svg.node().getBoundingClientRect().width || 300;
      const height = svg.node().getBoundingClientRect().height || 200;
      const margin = { top: 20, right: 20, bottom: 30, left: 40 };
      const chartWidth = width - margin.left - margin.right;
      const chartHeight = height - margin.top - margin.bottom;
      
      // Count points by Z-slice (rounded)
      const zCounts = {};
      filteredData.forEach(d => {
        const zSlice = Math.round(d.z_coordinate);
        zCounts[zSlice] = (zCounts[zSlice] || 0) + 1;
      });
      
      const data = Object.entries(zCounts)
        .map(([z, count]) => ({ z: parseFloat(z), count }))
        .sort((a, b) => a.z - b.z);
      
      const xScale = d3.scaleBand()
        .domain(data.map(d => d.z))
        .range([0, chartWidth])
        .padding(0.1);
      
      const yScale = d3.scaleLinear()
        .domain([0, d3.max(data, d => d.count)])
        .range([chartHeight, 0]);
      
      const g = svg.append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);
      
      g.append('g')
        .attr('transform', `translate(0,${chartHeight})`)
        .call(d3.axisBottom(xScale))
        .style('font-size', '8px');
      
      g.append('g')
        .call(d3.axisLeft(yScale))
        .style('font-size', '8px');
      
      g.selectAll('.bar')
        .data(data)
        .enter().append('rect')
        .attr('class', 'bar')
        .attr('x', d => xScale(d.z))
        .attr('width', xScale.bandwidth())
        .attr('y', d => yScale(d.count))
        .attr('height', d => chartHeight - yScale(d.count))
        .attr('fill', '#667eea');
    }

    function updateCellTypeChart() {
      const svg = d3.select('#cellTypeChart');
      if (svg.empty() || !filteredData || filteredData.length === 0 || !hasCellType) {
        svg.selectAll('*').remove();
        svg.append('text')
          .attr('x', '50%')
          .attr('y', '50%')
          .attr('text-anchor', 'middle')
          .attr('dominant-baseline', 'middle')
          .style('font-size', '10px')
          .style('fill', '#999')
          .text('Cell type data not available');
        return;
      }
      
      svg.selectAll('*').remove();
      
      const width = svg.node().getBoundingClientRect().width || 300;
      const height = svg.node().getBoundingClientRect().height || 200;
      const radius = Math.min(width, height) / 2 - 20;
      
      // Count cell types
      const cellTypeCounts = {};
      filteredData.forEach(d => {
        if (d.cell_type) {
          cellTypeCounts[d.cell_type] = (cellTypeCounts[d.cell_type] || 0) + 1;
        }
      });
      
      const data = Object.entries(cellTypeCounts).map(([type, count]) => ({ type, count }));
      
      const colorScalePie = d3.scaleOrdinal(d3.schemeCategory10);
      const pie = d3.pie().value(d => d.count);
      const arc = d3.arc().innerRadius(0).outerRadius(radius);
      
      const g = svg.append('g')
        .attr('transform', `translate(${width/2},${height/2})`);
      
      const arcs = g.selectAll('.arc')
        .data(pie(data))
        .enter().append('g')
        .attr('class', 'arc');
      
      arcs.append('path')
        .attr('d', arc)
        .attr('fill', (d, i) => colorScalePie(i))
        .attr('stroke', '#fff')
        .attr('stroke-width', 2);
      
      arcs.append('text')
        .attr('transform', d => `translate(${arc.centroid(d)})`)
        .attr('text-anchor', 'middle')
        .style('font-size', '8px')
        .text(d => d.data.count > 100 ? d.data.type.substring(0, 10) : '');
    }

    function updateSpatialDensityChart() {
      const svg = d3.select('#spatialDensityChart');
      if (svg.empty() || !filteredData || filteredData.length === 0) return;
      
      svg.selectAll('*').remove();
      
      const width = svg.node().getBoundingClientRect().width || 300;
      const height = svg.node().getBoundingClientRect().height || 200;
      const margin = { top: 20, right: 20, bottom: 30, left: 40 };
      const chartWidth = width - margin.left - margin.right;
      const chartHeight = height - margin.top - margin.bottom;
      
      // Create 2D histogram
      const xExtent = d3.extent(filteredData, d => d.x_coordinate);
      const yExtent = d3.extent(filteredData, d => d.y_coordinate);
      
      const binsX = 20;
      const binsY = 20;
      const binWidth = (xExtent[1] - xExtent[0]) / binsX;
      const binHeight = (yExtent[1] - yExtent[0]) / binsY;
      
      const bins = {};
      filteredData.forEach(d => {
        const xBin = Math.floor((d.x_coordinate - xExtent[0]) / binWidth);
        const yBin = Math.floor((d.y_coordinate - yExtent[0]) / binHeight);
        const key = `${xBin},${yBin}`;
        bins[key] = (bins[key] || 0) + 1;
      });
      
      const maxCount = d3.max(Object.values(bins));
      const colorScaleDensity = d3.scaleSequential(d3.interpolateViridis)
        .domain([0, maxCount]);
      
      const xScale = d3.scaleLinear()
        .domain(xExtent)
        .range([0, chartWidth]);
      
      const yScale = d3.scaleLinear()
        .domain(yExtent)
        .range([chartHeight, 0]);
      
      const g = svg.append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);
      
      Object.entries(bins).forEach(([key, count]) => {
        const [xBin, yBin] = key.split(',').map(Number);
        const x = xExtent[0] + xBin * binWidth;
        const y = yExtent[0] + yBin * binHeight;
        
        g.append('rect')
          .attr('x', xScale(x))
          .attr('y', yScale(y + binHeight))
          .attr('width', chartWidth / binsX)
          .attr('height', chartHeight / binsY)
          .attr('fill', colorScaleDensity(count))
          .attr('stroke', '#fff')
          .attr('stroke-width', 0.5);
      });
      
      g.append('g')
        .attr('transform', `translate(0,${chartHeight})`)
        .call(d3.axisBottom(xScale))
        .style('font-size', '8px');
      
      g.append('g')
        .call(d3.axisLeft(yScale))
        .style('font-size', '8px');
    }

    function updateExpressionViolinChart() {
      const svg = d3.select('#expressionViolinChart');
      if (svg.empty() || !filteredData || filteredData.length === 0) return;
      
      svg.selectAll('*').remove();
      
      const width = svg.node().getBoundingClientRect().width || 300;
      const height = svg.node().getBoundingClientRect().height || 200;
      const margin = { top: 20, right: 20, bottom: 50, left: 50 };
      const chartWidth = width - margin.left - margin.right;
      const chartHeight = height - margin.top - margin.bottom;
      
      // Count expression levels (detections) per gene
      const geneCounts = {};
      filteredData.forEach(d => {
        geneCounts[d.gene] = (geneCounts[d.gene] || 0) + 1;
      });
      
      // Get top genes (or all if fewer than 15)
      const genes = Object.entries(geneCounts)
        .map(([gene, count]) => ({ gene, count }))
        .sort((a, b) => b.count - a.count)
        .slice(0, 15)
        .map(d => d.gene);
      
      if (genes.length === 0) return;
      
      // Create kernel density estimation for each gene
      const violinData = genes.map(gene => {
        // For each gene, create a distribution based on detection counts
        const geneData = filteredData.filter(d => d.gene === gene);
        const count = geneCounts[gene];
        
        // Create histogram bins for KDE
        const bins = 30;
        const min = 0;
        const max = d3.max(Object.values(geneCounts));
        const binWidth = (max - min) / bins;
        
        // Count occurrences in each bin (using gene's total count as the value)
        const histogram = Array(bins).fill(0);
        const binIndex = Math.min(Math.floor((count - min) / binWidth), bins - 1);
        histogram[binIndex] = geneData.length; // All points contribute to this bin
        
        // Normalize to create density (smooth distribution)
        const maxDensity = d3.max(histogram);
        const density = histogram.map(h => maxDensity > 0 ? h / maxDensity : 0);
        
        // Apply smoothing kernel for better violin shape
        const smoothedDensity = density.map((d, i) => {
          let sum = 0;
          let weight = 0;
          const kernelSize = 3;
          for (let j = Math.max(0, i - kernelSize); j <= Math.min(bins - 1, i + kernelSize); j++) {
            const w = 1 - Math.abs(i - j) / (kernelSize + 1);
            sum += density[j] * w;
            weight += w;
          }
          return weight > 0 ? sum / weight : d;
        });
        
        return { gene, density: smoothedDensity, count };
      });
      
      // Scales
      const xScale = d3.scaleBand()
        .domain(genes)
        .range([0, chartWidth])
        .padding(0.2);
      
      const yScale = d3.scaleLinear()
        .domain([0, d3.max(Object.values(geneCounts))])
        .range([chartHeight, 0]);
      
      const g = svg.append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);
      
      // Draw violin plots
      violinData.forEach(({ gene, density, count }) => {
        const x = xScale(gene);
        const bandwidth = xScale.bandwidth();
        const centerX = x + bandwidth / 2;
        const maxWidth = bandwidth * 0.4; // Max width of violin
        
        // Create path for violin shape
        const pathData = [];
        const binWidth = (yScale.domain()[1] - yScale.domain()[0]) / density.length;
        
        // Left side
        for (let i = 0; i < density.length; i++) {
          const y = yScale.domain()[0] + i * binWidth;
          const width = density[i] * maxWidth;
          pathData.push([centerX - width, yScale(y)]);
        }
        
        // Right side (reverse)
        for (let i = density.length - 1; i >= 0; i--) {
          const y = yScale.domain()[0] + i * binWidth;
          const width = density[i] * maxWidth;
          pathData.push([centerX + width, yScale(y)]);
        }
        
        // Close path
        pathData.push(pathData[0]);
        
        // Draw violin shape
        const line = d3.line()
          .x(d => d[0])
          .y(d => d[1])
          .curve(d3.curveBasis);
        
        g.append('path')
          .datum(pathData)
          .attr('d', line)
          .attr('fill', colorScale(gene))
          .attr('opacity', 0.6)
          .attr('stroke', colorScale(gene))
          .attr('stroke-width', 1);
        
        // Draw median line
        g.append('line')
          .attr('x1', centerX - maxWidth)
          .attr('x2', centerX + maxWidth)
          .attr('y1', yScale(count))
          .attr('y2', yScale(count))
          .attr('stroke', '#333')
          .attr('stroke-width', 1.5);
      });
      
      // X axis
      g.append('g')
        .attr('transform', `translate(0,${chartHeight})`)
        .call(d3.axisBottom(xScale))
        .selectAll('text')
        .attr('transform', 'rotate(-45)')
        .style('text-anchor', 'end')
        .style('font-size', '7px');
      
      // Y axis
      g.append('g')
        .call(d3.axisLeft(yScale))
        .style('font-size', '8px');
      
      // Y axis label
      g.append('text')
        .attr('transform', 'rotate(-90)')
        .attr('y', -margin.left + 15)
        .attr('x', -chartHeight / 2)
        .style('text-anchor', 'middle')
        .style('font-size', '9px')
        .style('fill', '#666')
        .text('Expression Level (Detections)');
    }

    // Initialize on page load
    window.addEventListener('DOMContentLoaded', async function() {
      // Check if we're on file:// protocol
      if (window.location.protocol === 'file:') {
        // Show file input as the primary method (no sample selector needed)
        document.getElementById('fileInputGroup').style.display = 'flex';
        document.getElementById('sampleSelectorGroup').style.display = 'none';
        document.getElementById('status').style.display = 'none';
        return;
      }
      
      // HTTP/HTTPS - load manifest and initialize
      document.getElementById('status').textContent = 'Loading sample list...';
      document.getElementById('status').className = 'status loading';
      
      const manifestLoaded = await loadManifest();
      
      if (!manifestLoaded) {
        // Manifest failed to load - show error and fallback to file input
        document.getElementById('status').textContent = 'Error: Could not load sample list. Please use the file upload option below.';
        document.getElementById('status').className = 'status error';
        document.getElementById('fileInputGroup').style.display = 'flex';
        document.getElementById('sampleSelectorGroup').style.display = 'none';
        return;
      }
      
      // Initialize sample selector with loaded manifest
      initializeSampleSelector();
      
      // Automatically load first sample if available
      if (samples.length > 0) {
        document.getElementById('status').textContent = 'Loading...';
        document.getElementById('status').className = 'status loading';
        
        // Automatically load first sample
        setTimeout(() => {
          document.getElementById('sampleSelector').value = samples[0].path;
          loadSampleFromPath(samples[0].path);
        }, 100);
      } else {
        document.getElementById('status').textContent = 'No samples available. Please use the file upload option.';
        document.getElementById('status').className = 'status error';
        document.getElementById('fileInputGroup').style.display = 'flex';
      }
    });

    // Update legend height on window resize
    let resizeTimeout = null;
    window.addEventListener('resize', function() {
      if (resizeTimeout) {
        clearTimeout(resizeTimeout);
      }
      resizeTimeout = setTimeout(() => {
        updateLegendHeight();
      }, 100);
    });
  </script>
</body>
</html>
